---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/8/5 17:39
---
local EffectFactory = require("Engine/Systems/EffectSystem/EffectFactory")
local SkillConfigData = require("MainGame/ConfigData/SkillConfigData")
local EffectConfig = require("Engine/Systems/EffectSystem/EffectConfig")
local DamageConfigData = require("MainGame/ConfigData/DamageConfigData")
local PoolingStrategyTypeEnum = require("Engine/Systems/ResourceSystem/PoolingStrategyTypeEnum")
local StringUtil = require('Engine/Common/Utilities/StringUtil')
local tinsert, tremove = table.insert, table.remove

EffectManager = EffectManager or {
    m_IdIndex = 0,
    m_EffectInstanceMap = {},
    m_EffectIDToStaticCallbackIDMap = {},
    m_EffectReleaseList = {},
}

function EffectManager.CreateEffect(objOwner, id, autoStart, invokerId, targetId)
    local effectConfig = EffectConfig.Get(id)
    if effectConfig == nil then
        Logger.LogInfo("None config for effect:%s", tostring(id))
        return -1
    end

    local effect = EffectFactory.Create(id, effectConfig.m_Type, objOwner)
    if not effect then
        Logger.LogErrorFormat("(EffectManager)[CreateEffect]EffectFactory.Create Failed")
        Logger.Table(effectConfig)
        return -1
    end
    EffectManager.m_IdIndex = EffectManager.m_IdIndex + 1
    effect.m_InstanceId = EffectManager.m_IdIndex
    EffectManager.m_EffectInstanceMap[EffectManager.m_IdIndex] = effect
    --Logger.LogInfo("Create effect: id: %s, effect.m_InstanceId: %s, frame:%s", id, effect.m_InstanceId, Time.frameCount)
    if effect.SetTargetID and targetId ~= nil then
        effect:SetTargetID(targetId)
    end

    if effect.SetInvokerID and invokerId ~= nil then
        effect:SetInvokerID(invokerId)
    end

    if autoStart then
        effect:Start()
    end
    return EffectManager.m_IdIndex, effect
end

function EffectManager.DestroyEffect(id)
    --Logger.LogInfo("DestroyEffect:%s ,frame:%s", id, Time.frameCount)
    local effect = EffectManager.m_EffectInstanceMap[id]
    if effect == nil then
        return
    end

    local objOwner = effect.m_Owner
    if objOwner then
        local effectAmountControlComponent = objOwner.m_EffectAmountControlComponent
        if effectAmountControlComponent then
            effectAmountControlComponent:UnRegisterEffect(effect.m_Config.m_Id, effect.m_Config.m_BindPath)
        end
    end

    effect:Destroy()
    EffectManager.m_EffectInstanceMap[id] = nil
end

function EffectManager.GetEffect(id)
    return EffectManager.m_EffectInstanceMap[id]
end

function EffectManager.SetEffectSpeed(id, speed)
    local effect = EffectManager.m_EffectInstanceMap[id]
    if effect and effect.SetPlaySpeed then
        effect:SetPlaySpeed(speed)
    end
end

function EffectManager.SetEffectPosition(id, pos)
    local effect = EffectManager.m_EffectInstanceMap[id]
    if effect and effect.SetPosition then
        effect:SetPosition(pos)
    end
end

function EffectManager.Update(deltaTime)
    local releaseList = EffectManager.m_EffectReleaseList
    for i, v in pairs(EffectManager.m_EffectInstanceMap) do
        v:Update(deltaTime)
        if v:IsFinish() then
            tinsert(releaseList, i)
        end
    end

    for i = #releaseList, 1, -1 do
        EffectManager.DestroyEffect(releaseList[i])
        tremove(releaseList, i)
    end
end

function EffectManager.BeforeChangeScene()
    EffectManager.m_IsChangeSceneTaskDone = false
    for i, v in pairs(EffectManager.m_EffectInstanceMap) do
        if v then
            v:Destroy()
        end
    end
    EffectManager.m_EffectInstanceMap = {}
end

function EffectManager.AfterChangeScene()
    EffectManager.PreLoadHeroEffect()
end

function EffectManager.IsChangeSceneTaskDone()
    return EffectManager.m_IsChangeSceneTaskDone or false
end

---这里不需要缓存哪些加载过，因为只是在每次切场景加载，而每次切场景之前resourceManager会清pool
function EffectManager.PreLoadHeroEffect(callback)
    if EffectManager.m_IsHeroEffectPreLoaded then
        EffectManager.m_IsChangeSceneTaskDone = true
        return
    end


    if not ObjectManager.m_Hero then
        EffectManager.m_IsChangeSceneTaskDone = true
        return
    end
    local heroJob = ObjectManager.m_Hero.m_JobId
    if not heroJob then
        heroJob = 1
    end

    local needLoadEffectIDList = {}
    local loadedList = {}
    for i, v in pairs(SkillConfig) do
        local jobList = v.JobList
        if jobList and #jobList > 0 then
            ---check job
            if table.findFirstIndex(jobList, function (x) return x == heroJob end) > 0 then
                EffectManager.PreLoadSkillEffect(i, callback, needLoadEffectIDList, loadedList)
            end
        end
    end

    if not next(needLoadEffectIDList) then
        EffectManager.m_IsChangeSceneTaskDone = true
        if callback then
            callback()
        end
    end
    EffectManager.m_IsHeroEffectPreLoaded = true
end

function EffectManager.PreLoadSkillEffect(id, callback, needLoadEffectIDList, loadedList)
    needLoadEffectIDList = needLoadEffectIDList or {}
    loadedList = loadedList or {}
    local loadedCallback = function(effectID, succeed)
        needLoadEffectIDList[effectID] = nil
        if not next(needLoadEffectIDList) then
            EffectManager.m_IsChangeSceneTaskDone = true
            if callback then
                callback()
            end
        end
    end
    local config = SkillConfigData:Get(id)
    if not config then
        return
    end
    if config.SkillEffectsList then
        ---load skill effect, no repeat will occur because of its id structure
        for i, v in pairs(config.SkillEffectsList) do
            needLoadEffectIDList[v.Id] = 1
            EffectManager.PreLoadEffect(v.Id, loadedCallback)
        end
    end

    if config.Actions then
        ---load hit effect, need check repeat
        for i, v in pairs(config.Actions) do
            local damageConfig = DamageConfigData:Get(v)
            if damageConfig then
                local effectList = damageConfig.EffectList
                for i, v in pairs(effectList) do
                    if not loadedList[v] then
                        loadedList[v] = 1
                        needLoadEffectIDList[v] = 1
                        EffectManager.PreLoadEffect(v, loadedCallback)
                    end
                end
            end
        end
    end
end

function EffectManager.PreLoadEffect(effectID, callback)
    if not effectID then
        return
    end
    local config = EffectConfig.Get(effectID)
    if not config then
        return
    end

    if config.m_Type == 10 then 
        callback(effectID,true)
        return
    end

    if StringUtil.IsNullOrEmpty(config.m_Path) then
        Logger.Error("[EffectManager](PreLoadEffect)Null resource path for effect:"..tostring(effectID))
        return
    end

    ResourceManager.InstantiateAsync(config.m_Path,function(gameObject)
        if gameObject ~= nil then
            ResourceManager.ReleaseInstance(gameObject)
        else
            Logger.LogDebug("EffectManager.PreLoadEffect CallBack go nil:".. config.m_Path)
        end

        if callback then
            callback(effectID, gameObject ~= nil)
        end
    end, PoolingStrategyTypeEnum.DontDestroyOnLoad)
end

local function InstantiateAsyncCallback(gameObject, instanceID)
    --Logger.LogInfo("Effect Object : %s", instanceID)
    local effect = EffectManager.GetEffect(instanceID)
    if effect == nil then
        --Logger.Error("Effect Object not found: %s", instanceID)
        --Logger.Table(EffectManager.m_EffectInstanceMap)
        if gameObject ~= nil then
            ResourceManager.ReleaseInstance(gameObject)
        end
        return
    end

    effect:OnInstantiate(gameObject)
end

function EffectManager.RegisterStaticInstantiateCallback(effectID)
    if not effectID then
        Logger.LogErrorFormat("[EffectManager](RegisterStaticInstantiateCallback)Null effectID")
        return
    end
    local config = EffectConfig.Get(effectID)
    if not config then
        Logger.LogErrorFormat("[EffectManager](RegisterStaticInstantiateCallback)Effect Config not found:[{0}]", effectID)
        return
    end

    local id = ResourceManager.RegisterStaticInstantiateCallback(config.m_Path, InstantiateAsyncCallback)
    EffectManager.m_EffectIDToStaticCallbackIDMap[effectID] = id
end

function EffectManager.GetStaticInstantiateCallbackID(effectID)
    if not effectID then
        Logger.LogErrorFormat("[EffectManager](GetStaticInstantiateCallbackID)Null effectID")
        return nil
    end

    return EffectManager.m_EffectIDToStaticCallbackIDMap[effectID]
end

--暂时先将特效表全部加到StaticInstantiateCall中，实际项目中需要自行做决策
function EffectManager.RegisterAllEffectToStaticInstantiateCallback()
    for i, v in pairs(SkillConfig) do
        local config = SkillConfigData:Get(i)
        if config and config.SkillEffectsList then
            ---load skill effect, no repeat will occur because of its id structure
            for i, v in pairs(config.SkillEffectsList) do
                EffectManager.RegisterStaticInstantiateCallback(v.Id)
            end

            ---load hit effect, need check repeat
            if config.Actions then
                for i, v in pairs(config.Actions) do
                    local damageConfig = DamageConfigData:Get(v)
                    if damageConfig ~= nil then
                        local effectList = damageConfig.EffectList
                        for i, v in pairs(effectList) do
                            EffectManager.RegisterStaticInstantiateCallback(v)
                        end
                    end
                end
            end
        end
    end
end


return EffectManager