---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/7/23 20:59
---
---
---@class EffectBase
local EffectBase = class("EffectBase")
local EffectConfig = require("Engine/Systems/EffectSystem/EffectConfig")
local EffectStatus = require("Engine/Systems/EffectSystem/EffectStatus")
local EffectPosType = require("Engine/Systems/EffectSystem/EffectPosType")
local PoolingStrategyTypeEnum = require("Engine/Systems/ResourceSystem/PoolingStrategyTypeEnum")
local StringUtil = require("Engine/Common/Utilities/StringUtil")
local CacheEvent = require("Engine/Systems/EffectSystem/CacheEvent")
local ResourceManager = ResourceManager

function EffectBase:Ctor(id, objOwner)
    self.m_Speed = 1
    self.m_Time = 0
    ---@type UnityEngine.GameObject
    self.m_Instance = nil
    ---@type EffectStatus
    self.m_Status = EffectStatus.UnInit
    ---@type List<CacheEvent>
    self.m_EventSet = {}
    ---@type EffectConfig
    if id ~= nil then
        self.m_Config = EffectConfig.Get(id)
        if self.m_Config == nil then
            Logger.LogError("[EffectBase](Ctor)None config for id :" .. id)
            return
        end
    end
    self.m_BindPath = self.m_Config.m_BindPath
    self.m_IsDestroy = false
    self.m_IsLoadFinish = false
    ---@type SGObject
    self.m_Owner = objOwner
    self.m_PoolingStrategyType = self:GetPoolingStrategyType()
end

function EffectBase:LoadResource()
    local path = self.m_Config.m_Path
    local id = self.m_Config.m_Id
    self.m_LoadBeginTime = Time.time
    if string.IsNullOrEmpty(path) then
        Logger.LogError("[EffectBase](LoadResource)Invalid effect path for id :" .. id)
        return
    end
    local staticCallbackID = EffectManager.GetStaticInstantiateCallbackID(id)
    if staticCallbackID ~= nil then
        self.m_ResourceHandle = ResourceManager.InstantiateAsyncByStaticCallback(staticCallbackID, self.m_PoolingStrategyType,
                self.m_InstanceId)
    else
        --Logger.LogDebugFormat("{0}:frameCount:{1}", self.m_Config.m_Path, Time.frameCount)
        self.m_ResourceHandle = ResourceManager.InstantiateAsync(self.m_Config.m_Path, function(gameObject)
            self:OnInstantiate(gameObject)
        end, self.m_PoolingStrategyType)
    end
end

function EffectBase:OnInstantiate(gameObject)
    if gameObject == nil then
        Logger.LogDebugFormat("[EffectBase](OnInstantiate)CallBack go nil:{0}", self.m_Config.m_Path)
        return
    end
    --Logger.LogInfo("%s:frameCount:%s, LoadTime:%s", self.m_Config.m_Path, Time.frameCount, Time.time - self.m_LoadBeginTime)

    if self.m_IsDestroy then
        ResourceManager.ReleaseInstance(self.m_ResourceHandle)
        return
    end

    self.m_Instance = gameObject
    gameObject:SetActive(true)

    if self.m_Owner:IsValid() == false then
        self:Destroy()
        return
    end

    --gameObject.name = tostring(self.m_InstanceId)

    if self:IsNeedEffectBehaviour() then
        if EffectBase.s_EffectBehaviourType == nil then
            EffectBase.s_EffectBehaviourType = System.Type.GetType("SGEngine.Core.EffectBehaviour")
        end
        self.m_EffectBehaviour = Core_ForLuaUtility.GetOrAddComponent(gameObject, EffectBase.s_EffectBehaviourType)
        self.m_EffectBehaviour:ResetAnimation()
        if self.m_Owner:IsHero() == false then
            self.m_EffectBehaviour:SetHideEffectActive(false)
        else
            self.m_EffectBehaviour:SetHideEffectActive(true)
        end
        self:SetPlaySpeed(self.m_Owner:GetCurrentPlaySpeed())
    end
    --local s = System.Type.GetType("SGEngine.Core.TestBehaviour")
    --Core_ForLuaUtility.GetOrAddComponent(gameObject, s)
    self:DoCacheEvent()
    self:OnLoadModelSuccess()
end

function EffectBase:OnLoadModelSuccess()
    self.m_IsLoadFinish = true
end

function EffectBase:GetPoolingStrategyType()
    if self.m_Owner:IsHero() == true then
        return PoolingStrategyTypeEnum.EffectDontDestroyOnLoad
    end
    return PoolingStrategyTypeEnum.EffectDefault
end

function EffectBase:IsNeedEffectBehaviour()
    return true
end

function EffectBase:Start(needLoadResource)
    if needLoadResource == nil then
        needLoadResource = true
    end
    self.m_Speed = 1
    self.m_Time = 0
    self:InitPosition()
    if needLoadResource then
        self:LoadResource()
    end
    self:SetActive(true)
    self.m_Status = EffectStatus.Started
end

function EffectBase:Finish()
    self:SetActive(false)
    self.m_Status = EffectStatus.Ended
end

function EffectBase:IsFinish()
    return self.m_Status == EffectStatus.Ended
end

function EffectBase:InitPosition()
    local config = self.m_Config
    local bindPah = self.m_BindPath
    if config.m_PosType == EffectPosType.None then
        return
    end

    local rotationOffset = config.m_RotationOffset
    local positionOffset = config.m_PositionOffset

    if config.m_PosType < EffectPosType.Bind then
        local positionX, positionY, positionZ, rotationX, rotationY, rotationZ, rotationW
        local isValid = false

        if not string.IsNullOrEmpty(bindPah) then
            isValid, positionX, positionY, positionZ = self.m_Owner:GetBodyPartTransformPositionXYZ(bindPah)
            isValid, rotationX, rotationY, rotationZ, rotationW = self.m_Owner:GetBodyPartTransformRotationXYZW(bindPah)
        end

        if isValid == false then
            positionX, positionY, positionZ = self.m_Owner:GetPositionXYZ()
            rotationX, rotationY, rotationZ, rotationW = self.m_Owner:GetRotationXYZW()
        end

        if config.m_PosType == EffectPosType.ByBindPositionAndRotation then
            if rotationOffset then
                self:SetRotationXYZWWithOffset(rotationX, rotationY, rotationZ, rotationW, rotationOffset)
            else
                self:SetRotationXYZW(rotationX, rotationY, rotationZ, rotationW)
            end
            if positionOffset then
                self:SetPositionXYZWithOffset(positionX, positionY, positionZ, positionOffset)
            else
                self:SetPositionXYZ(positionX, positionY, positionZ)
            end
        elseif config.m_PosType == EffectPosType.ByBindPositionOnly then
            if positionOffset then
                self:SetPositionXYZWithOffset(positionX, positionY, positionZ, positionOffset)
            else
                self:SetPositionXYZ(positionX, positionY, positionZ)
            end
        elseif config.m_PosType == EffectPosType.ByBindRotationOnly then
            if rotationOffset then
                self:SetRotationXYZWWithOffset(rotationX, rotationY, rotationZ, rotationW, rotationOffset)
            else
                self:SetRotationXYZW(rotationX, rotationY, rotationZ, rotationW)
            end
        end
    else
        self:BindToParent(bindPah)
        if config.m_PosType == EffectPosType.Bind then
            --self:SetLocalPosition(Vector3.zero)
            --self:SetLocalRotation(Quaternion.identity)
        elseif config.m_PosType == EffectPosType.BindWithPositionOnly then
            if positionOffset then
                self:SetLocalPosition(positionOffset)
            end
        elseif config.m_PosType == EffectPosType.BindWithRotationOnly then
            if rotationOffset then
                self:SetLocalRotation(rotationOffset)
            end
        elseif config.m_PosType == EffectPosType.BindWithPositionAndRotation then
            if rotationOffset then
                self:SetLocalRotation(rotationOffset)
            end

            if positionOffset then
                self:SetLocalPosition(positionOffset)
            end
        end
    end
    local scale = config.m_Scale
    --使用Vector.one 会有GC  所以展开
    if scale and (scale.x ~= 1 or scale.y ~= 1 or scale.z ~= 1) then
        self:SetLocalScale(scale)
    else
        self:SetLocalScale(1 ,1,1)
    end
end

function EffectBase:ResetTransform(resetScale)
    Core_ForLuaUtility.ResetTransform(self.m_Instance, resetScale)
end

function EffectBase:SetPosition(pos)
    self:SetPositionXYZ(pos.x, pos.y, pos.z)
end

function EffectBase:SetPositionXYZ(posX, posY, posZ)
    if self.m_Instance == nil then
        self:AddCacheEvent("SetPositionXYZ", posX, posY, posZ)
        return
    end
    Core_ForLuaUtility.SetPosition(self.m_Instance, posX, posY, posZ)
end

function EffectBase:SetRotationXYZW(x, y, z, w)
    ---@type UnityEngine.Quaternion
    if self.m_Instance == nil then
        self:AddCacheEvent("SetRotationXYZW", x, y, z, w)
        return
    end
    Core_ForLuaUtility.SetRotation(self.m_Instance, x, y, z, w)
end

function EffectBase:SetPositionXYZWithOffset(x, y, z, offset)
    ---@type UnityEngine.Vector3
    if self.m_Instance == nil then
        self:AddCacheEvent("SetPositionXYZWithOffset", x, y, z, offset)
        return
    end
    Core_ForLuaUtility.SetPositionWithOffset(self.m_Instance, x, y, z, offset.x, offset.y, offset.z)
end

function EffectBase:SetRotationXYZWWithOffset(x, y, z, w, offset)
    ---@type UnityEngine.Quaternion
    if self.m_Instance == nil then
        self:AddCacheEvent("SetRotationXYZWWithOffset", x, y, z, w, offset)
        return
    end
    Core_ForLuaUtility.SetRotationWithOffset(self.m_Instance, x, y, z, w, offset.x, offset.y, offset.z)
end

function EffectBase:SetPositionAndRotationWithOffset(position, rotation, posOffset, rotOffset)
    self:SetPositionXYZAndRotationXXYZWWithOffset(
            position.x, position.y, position.z,
            rotation.x, rotation.y, rotation.z, rotation.w,
            posOffset, rotOffset)
end

function EffectBase:SetPositionXYZAndRotationXXYZWWithOffset(posX, posY, posZ, rotX, rotY, rotZ, rotW, posOffset, rotOffset)
    if self.m_Instance == nil then
        self:AddCacheEvent("SetPositionXYZAndRotationXXYZWWithOffset", posX, posY, posZ, rotX, rotY, rotZ, rotW, posOffset, rotOffset)
        return
    end
    Core_ForLuaUtility.SetPositionAndRotationWithOffset(self.m_Instance,
            posX, posY, posZ,
            rotX, rotY, rotZ, rotW,
            posOffset.x, posOffset.y, posOffset.z,
            rotOffset.x, rotOffset.y, rotOffset.z)
end

function EffectBase:SetLocalPosition(pos)
    ---@type UnityEngine.Vector3
    if self.m_Instance == nil then
        self:AddCacheEvent("SetLocalPosition", pos)
        return
    end
    Core_ForLuaUtility.SetLocalPosition(self.m_Instance, pos.x, pos.y, pos.z)
end

function EffectBase:SetLocalRotation(rotation)
    ---@type UnityEngine.Quaternion
    if self.m_Instance == nil then
        self:AddCacheEvent("SetLocalRotation", rotation)
        return
    end
    Core_ForLuaUtility.SetLocalRotation(self.m_Instance, rotation.x, rotation.y, rotation.z)
end

function EffectBase:SetLocalPositionAndRotation(position, rotation)
    ---@type UnityEngine.Quaternion
    if self.m_Instance == nil then
        self:AddCacheEvent("SetLocalPositionAndRotation", position, rotation)
        return
    end
    Core_ForLuaUtility.SetLocalPositionAndRotation(self.m_Instance, position.x, position.y, position.z, rotation.x, rotation.y, rotation.z)
end

function EffectBase:SetLocalScale(scaleX, scaleY, scaleZ)
    ---@type UnityEngine.Vector3
    if self.m_Instance == nil then
        self:AddCacheEvent("SetLocalScale", scaleX, scaleY, scaleZ)
        return
    end
    Core_ForLuaUtility.SetLocalScale(self.m_Instance, scaleX, scaleY, scaleZ)
end

function EffectBase:BindToParent(hangPointPath)
    ---@type UnityEngine.Transform
    if self.m_Instance == nil then
        self:AddCacheEvent("BindToParent", hangPointPath)
        return
    end

    if not self.m_Owner or not self.m_Owner:IsValid() then
        return
    end

    self.m_Owner.m_Core:BindAttachmentToHangPoint(self.m_Instance, hangPointPath, true)
end

function EffectBase:SetActive(active)
    ---@type bool
    if self.m_Instance == nil then
        self:AddCacheEvent("SetActive", active)
        return
    end
    self.m_Instance:SetActive(active)
end

function EffectBase:SetParent(parent)
    ---@type UnityEngine.Transform
    if self.m_Instance == nil then
        self:AddCacheEvent("SetParent", parent)
        return
    end
    if parent == nil then
        return
    end
    self.m_Instance.transform:SetParent(parent)
end

function EffectBase:Rotate(angleX, angleY, angleZ)
    if self.m_Instance == nil then
        self:AddCacheEvent("Rotate", angleX, angleY, angleZ)
        return
    end
    Core_ForLuaUtility.RotateGameObject(self.m_Instance, angleX, angleY, angleZ)
end

---@return boolean
function EffectBase:IsAvailable()
    return self.m_Status ~= EffectStatus.Ended
end

---@type private
function EffectBase:AddCacheEvent(call, ...)
    ---@type CacheEvent
    local cacheEvent = CacheEvent.New(self, call, ...)
    if self.m_EventSet == nil then
        self.m_EventSet = {}
    end
    table.insert(self.m_EventSet, cacheEvent)
end

function EffectBase:DoCacheEvent()
    local eventSet = self.m_EventSet
    local length = #eventSet
    for i = 1, length do
        eventSet[i]:Invoke()
    end
end

function EffectBase:Destroy()
    self.m_IsDestroy = true
    if self.m_Instance == nil or self.m_Instance:Equals(nil) then
        return
    end
    self.m_Instance:SetActive(false)
    ResourceManager.ReleaseInstance(self.m_ResourceHandle)
    self.m_ResourceHandle = nil
    self.m_Instance = nil
    self.m_EffectBehaviour = nil
    self.m_ParticleSystem = nil
end

function EffectBase:Freeze()
    if self.m_NotInfluencedByPlaySpeed then
        return
    end
    self:SetPlaySpeed(0)
end

function EffectBase:UnFreeze()
    if self.m_NotInfluencedByPlaySpeed then
        return
    end
    self:SetPlaySpeed(1)
end

function EffectBase:SetPlaySpeed(speed)
    self.m_Speed = speed
    if self.m_EffectBehaviour then
        self.m_EffectBehaviour:SetPlaySpeed(speed)
    end
end

function EffectBase:Update(deltaTime)
    if self.m_Instance == nil then
        return
    end
    if self.m_NotInfluencedByPlaySpeed then
        self.m_Time = self.m_Time + deltaTime
    else
        local myDeltaTime = deltaTime * self.m_Speed
        self.m_Time = self.m_Time + myDeltaTime
    end

    local duration = self.m_Config.m_Duration
    if duration > 0 and self.m_Time > duration and self:IsAvailable() then
        self:Finish()
    end
end

function EffectBase:StartFadeOut(fadeOutTime)
    if self:IsLoadFinish() == false then
        return
    end
    self.m_EffectBehaviour:StartParticleFadeOut(fadeOutTime)
end

function EffectBase:StopFadeOut()
    if self:IsLoadFinish() == false then
        return
    end
    self.m_EffectBehaviour:StopParticleFadeOut()
end

function EffectBase:IsLoadFinish()
    return self.m_IsLoadFinish
end

return EffectBase
