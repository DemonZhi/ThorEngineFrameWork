---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/9/14 18:12
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local EffectConfig = require("Engine/Systems/EffectSystem/EffectConfig")
local ComponentEffect = class("ComponentEffect", ComponentBase)
ComponentEffect.m_ComponentId = ComponentDefine.ComponentType.k_ComponentEffect

function ComponentEffect:Init(object)
    ComponentEffect.__super.Init(self, object)
    self.m_EffectMap = {}
    self.m_DelayStopEffectMap = {}
    self.m_ReleaseList = {}
end

function ComponentEffect:Destroy()
    self:DestroySkillRelatedEffect()
    self.m_EffectMap = nil
    self.m_DelayStopEffectMap = nil
    self.m_ReleaseList = nil
    ComponentEffect.__super.Destroy(self)
end

function ComponentEffect:PlaySkillEffect(skillEffectsList)
    self.m_SkillEffectList = skillEffectsList
end

function ComponentEffect:PlayNormalEffect(effectId, autoStart)
    if effectId == nil then
        return -1
    end
    if autoStart == nil then
        autoStart = true
    end

    local effectIndex, effect = EffectManager.CreateEffect(self.m_Owner, effectId, autoStart)
    --Logger.LogInfo("PlayNormalEffect: effectId:%s, effectIndex:%s", effectId, effectIndex)
    return effectIndex, effect
end

function ComponentEffect:StopNormalEffect(effectIndex, delayTime)
    if effectIndex == nil then
        return
    end
    delayTime = delayTime or 0
    --Logger.LogInfo("StopNormalEffect: effectIndex:%s, delayTime:%s", effectIndex, delayTime)
    if delayTime <= 0 then
        EffectManager.DestroyEffect(effectIndex)
    else
        --Logger.LogInfo("DelayRemove: effectIndex:%s, delayTime:%s", effectIndex, delayTime)
        self.m_DelayStopEffectMap[effectIndex] = delayTime
    end
end

function ComponentEffect:Update(deltaTime)
    for i, v in pairs(self.m_DelayStopEffectMap) do
        local delayTime = v
        if delayTime ~= nil then
            delayTime = delayTime - deltaTime
            self.m_DelayStopEffectMap[i] = delayTime
            if delayTime <= 0 then
                table.insert(self.m_ReleaseList, i)
                --Logger.LogInfo("DelayRemove: effectIndex:%s", i)
                EffectManager.DestroyEffect(i)
            end
        end
    end

    for i = #self.m_ReleaseList, 1, -1 do
        local effectIndex = self.m_ReleaseList[i]
        if effectIndex then
            self.m_DelayStopEffectMap[effectIndex] = nil
        end
        self.m_ReleaseList[i] = nil
    end
end

function ComponentEffect:PlaySkillEffectCore(config)
    local isHeroOnly = config.IsHeroOnly == 1
    local owner = self.m_Owner
    if isHeroOnly and owner:IsHero() == false then
        return
    end

    local currentSkill = owner.m_SkillComponent:GetCurrentSkill()
    local targetId
    if currentSkill then
        targetId = currentSkill:GetTargetID()
    end
    local effectId = EffectManager.CreateEffect(owner, config.Id, true, owner:GetObjectID(), targetId)
    if effectId > 0 then
        self.m_EffectMap[effectId] = config
    end
end

function ComponentEffect:DestroySkillRelatedEffect()
    if not self.m_EffectMap then
        return
    end
    for i, v in pairs(self.m_EffectMap) do
        if v.IsDestroyOnSkillEnd == 1 then
            table.insert(self.m_ReleaseList, i)
            EffectManager.DestroyEffect(i)
        end
    end

    for i = #self.m_ReleaseList, 1, -1 do
        local effectIndex = self.m_ReleaseList[i]
        if effectIndex then
            self.m_EffectMap[i] = nil
        end
        self.m_ReleaseList[i] = nil
    end

    self.m_SkillEffectList = nil
end

function ComponentEffect:HandleAnimationEvent(eventName)
    if not self.m_SkillEffectList then
        return
    end

    for i, v in pairs(self.m_SkillEffectList) do
        if v.BeginEvent == eventName then
            self:PlaySkillEffectCore(v)
        end
    end
end

function ComponentEffect:SetSpeed(speed)
    if not self.m_EffectMap then
        return
    end
    for i, v in pairs(self.m_EffectMap) do
        if v ~= nil then
            EffectManager.SetEffectSpeed(i, speed)
        end
    end
end

function ComponentEffect:FreezeActiveEffects()
    if not self.m_EffectMap then
        return
    end
    for i, v in pairs(self.m_EffectMap) do
        local effect = EffectManager.GetEffect(i)
        if effect then
            effect:Freeze()
        end
    end
end

function ComponentEffect:UnFreezeActiveEffects()
    if not self.m_EffectMap then
       return
    end
    for i, v in pairs(self.m_EffectMap) do
        local effect = EffectManager.GetEffect(i)
        if effect then
            effect:UnFreeze()
        end
    end
end

function ComponentEffect:StartEffectFadeOut(effectIndex, fadeOutTime)
    local effect = EffectManager.GetEffect(effectIndex)
    if not effect then
        return
    end

    effect:StartFadeOut(fadeOutTime)
end

function ComponentEffect:StopEffectFadeOut(effectIndex)
    local effect = EffectManager.GetEffect(effectIndex)
    if not effect then
        return
    end

    effect:StopFadeOut()
end

return ComponentEffect