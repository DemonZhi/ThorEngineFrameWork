---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/11/4 10:32
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local MakeUpDefine = require("MainGame/UI/Module/Makeup/Model/Define/MakeUpDefine")
local ComponentFaceMakeUp = class("ComponentFaceMakeUp", ComponentBase)
ComponentFaceMakeUp.m_ComponentId = ComponentDefine.ComponentType.k_ComponentFaceMakeUp

local BLENDSHAPEMODE = 1
local TRANSFORMMODE = 0
local k_FacePart = 'mod_role_fa_01'
local k_EyebrowPart = 'mod_role_eb'
local k_CorneaPart = 'mod_role_el'
local k_EyeLPart = 'mod_role_ey_01'
local k_EyeRPart = 'mod_role_ey_02'

local TextureMap = 
{
    [1] = "lipsTex",
    [2] = "eyebrowTex",
    [3] = "eyeshadowTex",
    [4] = "tattooTex",
}

local k_TextureKey = 
{
    [0] = "eyeLinearTex",
    [1] = "tattooTex",   
    [2] = "nosecontourTex",   
    [3] = "cheekcontourTex",   
    [4] = "jawcontourTex",   
    [5] = "blushTex",   
    [6] = "lipsTex",   
    [7] = "eyeWrinkleTex",   
    [8] = "eyeshadowTex",   
    [9] = "eyebrowbgTex",   
    [10] = "eyebrowTex",   
    [11] = "spotTex",   
    [12] = "moleTex",   
    [13] = "wrinkleTex",   
    [14] = "lipsWrinkleTex",   
    [15] = "irisLTex",   
    [16] = "corneaTex",   
    [17] = "irisRTex",   
}

local k_MakeUpConfigKey = "pinchFaceConfig_female"

function ComponentFaceMakeUp:Init(object)
    ComponentFaceMakeUp.__super.Init(self, object)
    self.m_BlendShapeList = {}
    self.m_FaceTexList = {}
    self.m_HairColor = {}
    self.m_HairColor2 = {}
    self.m_TextureMap = {}
    self.moleBiasBase = MakeUpDefine.FaceMakeupInitData.moleBias
    self.tattooBiasBase = MakeUpDefine.FaceMakeupInitData.tattooBias
    self.spotBiasBase = MakeUpDefine.FaceMakeupInitData.spotBias
    self.jawcontourBiasBase = MakeUpDefine.FaceMakeupInitData.jawcontourBias
end

function ComponentFaceMakeUp:Destroy()
    if self.m_ScriptableObject then 
        ResourceManager.ReleaseScriptableObject(self.m_ScriptableObject)
        self.m_ScriptableObject = nil
    end

    for k,v in pairs(self.m_TextureMap) do
        ResourceManager.ReleaseTexture(v)
    end
    self.m_TextureMap = nil

    ComponentFaceMakeUp.__super.Destroy(self)
end

function ComponentFaceMakeUp:Deserialize(netBuffer)
    ---blendshape
    local length = netBuffer:ReadUByte()
    for i = 1, length do
        local weight = netBuffer:ReadFloat()
        self.m_BlendShapeList[i] = weight
    end

    ---body
    length = netBuffer:ReadUByte()
    for i = 1, length do
        local multiplier = netBuffer:ReadFloat()
    end

    ---face texture
    length = netBuffer:ReadUByte()
    for i = 1, length do
        local textureIndex = netBuffer:ReadShort()
        self.m_FaceTexList[i] = textureIndex
    end

    ---skin color
    self.m_SkinColorIndex = netBuffer:ReadShort()

    ---hair color
    self.m_HairColor.r = netBuffer:ReadFloat()
    self.m_HairColor.g = netBuffer:ReadFloat()
    self.m_HairColor.b = netBuffer:ReadFloat()

    ---hair color2
    self.m_HairColor2.r = netBuffer:ReadFloat()
    self.m_HairColor2.g = netBuffer:ReadFloat()
    self.m_HairColor2.b = netBuffer:ReadFloat()

    ---hair color2 strength
    self.m_HairColor2_strength = netBuffer:ReadFloat()
end

function ComponentFaceMakeUp:SetFaceBlendShapeValue(id, value)
    if not self.m_Owner then
        return
    end 

    self.m_Owner.m_Core:SetPinchValue(BLENDSHAPEMODE, id, value, k_FacePart)
end

function ComponentFaceMakeUp:SetFaceTransformValue(id, value)
    if not self.m_Owner or not self.m_ScriptableObject then
        return
    end 
    self.m_Owner.m_Core:SetPinchValue(TRANSFORMMODE, id, value, k_FacePart)
end

function ComponentFaceMakeUp:GetBlendShapeByIndex(id)
    if not self.m_Owner then
        return
    end 
    
    return self.m_Owner.m_Core:GetBlendShapeByIndex(id, k_FacePart)
end

function ComponentFaceMakeUp:ApplyMakeup(blendshapeList, textureIndexList)   
    if not self.m_Owner then
        return
    end 
    
    for i = 1, #blendshapeList, 1 do
        --self.m_Owner.m_Core:SetPinchValue(1, i-1, blendshapeList[i], 'Face')
        self:SetFaceBlendShapeValue(i-1, blendshapeList[i])
    end

    local makeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    if makeupData then
        for i = 1, #textureIndexList, 1 do
            local path = self:GetPathByIndex(i, textureIndexList[i])
            if path then
                local texture = ResourceManager.LoadTexture(path)   
                makeupData[TextureMap[i]] = texture    
            else
                makeupData[TextureMap[i]] = nil
            end
        end
        self:RefreshFace()
    end
end

function ComponentFaceMakeUp:GetTexture(path)
    if path == nil or path == "" then 
        return nil
    end

    if self.m_TextureMap[path] then 
        return self.m_TextureMap[path]
    else
        local texture = ResourceManager.LoadTexture(path) 
        self.m_TextureMap[path] = texture
        return texture
    end
end

function ComponentFaceMakeUp:ApplyMakeupSync() 
    if not self.m_Owner then
        return
    end 
    
    local blendshapeList = self.m_BlendShapeList
    local textureIndexList = self.m_FaceTexList

    for i = 1, #blendshapeList, 1 do
        self:SetFaceBlendShapeValue(i-1, blendshapeList[i])
    end

    local makeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    if makeupData then
        local needRefresh = false
        if #textureIndexList <= 0 then
            needRefresh = true
        end
        
        for k, v in ipairs(textureIndexList) do
            local path = self:GetPathByIndex(k, v)
            if path then
                ResourceManager.LoadTextureAsync(path, function(texture)
                        --makeupData[TextureMap[i]] = texture 
                        self:SetFaceMakeupData(TextureMap[k], texture) 
                        --todo 这里不能调用同步接口，只能在最后一次回调中合一下图
                        -- if i == #textureIndexList then
                        --     self:RefreshFace()
                        -- end
                    end 
                ) 
            else
                needRefresh = true                  
            end
        end

        if needRefresh then
            self:RefreshFace()
        end
        --self:RefreshFace()
    end
end

function ComponentFaceMakeUp:GetPathByIndex(type, index)
    if index <= 0 then
        return nil
    end
    
    if type == 1 then
        return string.format("lip_%d_%d", self.gender, index)
    elseif type == 2 then
        return string.format("eyebrow_%d_%d", self.gender, index)
    elseif type == 3 then
        return string.format("eyeshadow_%d_%d", self.gender, index)
    elseif type == 4 then
        return string.format("tattoo_%d_%d", self.gender, index)
    else 
        return nil
    end
end

function ComponentFaceMakeUp:OnModelLoadComplete()

    --当前动画状态不支持蒙皮，不用走换脸的逻辑
    if self.m_Owner.m_Core.AnimationType > 0 then
        return        
    end
    -- self:ResetFace()
    -- if self.m_Owner and self.m_Owner:IsPlayer() then
    --     local gender = self.m_Owner.m_AttrComponent:GetGender()
    --     self:ChangeGender(gender)
    -- end
    -- self:ApplyMakeupSync()
    local faceMakeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    faceMakeupData.spotBias = self.spotBiasBase
    faceMakeupData.jawcontourBias = self.jawcontourBiasBase
    for propertyName, value in pairs(MakeUpDefine.FaceMakeupInitData) do
        if faceMakeupData[propertyName] then 
            faceMakeupData[propertyName] = value
        end
    end
end

function ComponentFaceMakeUp:SetData(blendshapeList, textureIndexList)
    self.m_BlendShapeList = blendshapeList
    self.m_FaceTexList = textureIndexList
end

function ComponentFaceMakeUp:ResetFace()
    if not self.m_Owner then
        return
    end

    local count = self.m_Owner.m_Core:GetBlendShapeCount(k_FacePart)
    for i = 1, count, 1 do
        self:SetFaceBlendShapeValue(i-1, 50)
    end

    local makeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    if makeupData then
        for i = 1, #TextureMap, 1 do 
            makeupData[TextureMap[i]] = nil
        end
    end

    self:RefreshFace()
end

function ComponentFaceMakeUp:RefreshFace()
    if not self.m_Owner then
        return
    end

    self.m_Owner.m_Core:ChangeFace(k_FacePart)
    
    local faceMakeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    if faceMakeupData.eyebrowTex ~= nil then 
        self.m_Owner.m_Core:ChangeEyebrow(k_EyebrowPart)
    end

    if faceMakeupData.corneaTex ~= nil then 
        self.m_Owner.m_Core:ChangeCornea(k_CorneaPart)
    end

    if faceMakeupData.irisLTex ~= nil then 
        self.m_Owner.m_Core:ChangeEye(k_EyeLPart)
    end

    if faceMakeupData.irisRTex ~= nil then 
        self.m_Owner.m_Core:ChangeEyeR(k_EyeRPart)
    end
end

function ComponentFaceMakeUp:GetFaceBlendShapeList()
    if not self.m_Owner then
        return {}
    end

    local blendshapeList = {}
    local length = self.m_Owner.m_Core:GetBlendShapeCount(k_FacePart)
    for i=1, length do
        blendshapeList[i] = self:GetBlendShapeByIndex(i-1)
    end

    return blendshapeList
end

--todo 这里的匹配并不通用，后面可以通过规范贴图命名来处理
function ComponentFaceMakeUp:GetFaceTextureIndexList()
    if not self.m_Owner then
        return {}
    end

    local textureIndexList = {}
    local makeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    for i=1, #TextureMap, 1 do
        local texture = makeupData[TextureMap[i]]
        if texture then
            local textureName = texture.name
            textureIndexList[i] = string.match(string.reverse(textureName), "%d+") --todo, 后面找一个更好的方法
        else
            textureIndexList[i] = 0
        end
    end

    return textureIndexList
end

function ComponentFaceMakeUp:SetFaceMakeupData(type, value)
    if not self.m_Owner then
        return
    end
    
    local makeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    if makeupData then
        makeupData[type] = value
        self:RefreshFace()
    end
end

--------- 古风操做
function ComponentFaceMakeUp:SetTextureValue(faceMakeupData, index, value, prefix, suffix)
    if value == "" or value == nil then
        faceMakeupData.partTexName[index]      = ""
    else
        faceMakeupData.partTexName[index]      = table.concat({prefix, value, suffix})
    end
    faceMakeupData.partTexIsDirty[index]       = true
    faceMakeupData[k_TextureKey[index]] = self:GetTexture(faceMakeupData.partTexName[index])
end

-- 妆容设置贴图操作
function ComponentFaceMakeUp:SetTextureValueByConfig(faceMakeupData, config, value)
    local index = config[1]
    local prefix = config[2]
    local suffix = config[3]
    local colorParamName = config[4]

    if value == "" or value == nil then
        faceMakeupData.partTexName[index]      = ""
    else
        faceMakeupData.partTexName[index]      = table.concat({prefix, value, suffix})
    end
    faceMakeupData.partTexIsDirty[index]       = true
    faceMakeupData[k_TextureKey[index]] = self:GetTexture(faceMakeupData.partTexName[index])

    -- 设置明度系数
    if colorParamName then 
        local colorParam = faceMakeupData[colorParamName]
        local tab = string.split(faceMakeupData.partTexName[index], "_")
        local iID = tonumber(tab[#tab-1]) or 0
        -- 设置贴图，将明度范围设置为【1,1】，不受染色影响
        colorParam.y = 1
        colorParam.z = 1
        -- 设置染色强度
        colorParam.x = MakeupController.model:GetLuminance(iID)
        faceMakeupData[colorParamName] = colorParam
    end
end

-- 妆容，设置染色操作
function ComponentFaceMakeUp:SetDyeColor(faceMakeupData, config, value)
    local colorName = config[1]
    local colorParamName = config[2]
    local colorParam = faceMakeupData[colorParamName]
    faceMakeupData[colorName] = value
    if colorParam.y == 1 then 
        colorParam.y = 0
        colorParam.z = 1
        faceMakeupData[colorParamName] = colorParam
    end
end

-- 妆容，设置属性操作
function ComponentFaceMakeUp:SetMakeupDataPropertyValue(valueTypeConfig, value)
    local faceMakeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    local propertyName = valueTypeConfig[1]
    local changeValueFun = valueTypeConfig[2]

    if changeValueFun then  
        value = changeValueFun(value)
    end
    faceMakeupData[propertyName] = value
end

-- 妆容，设置容色强度
function ComponentFaceMakeUp:SetDyeColorIntensity(faceMakeupData, config, value)
    local colorParamName = config[1]
    local colorParam = faceMakeupData[colorParamName]
    colorParam.x = value
    faceMakeupData[colorParamName] = colorParam
end

-- 妆容，设置染色开关
function ComponentFaceMakeUp:SetDyeColorEnabled(faceMakeupData, config, value)
    local colorParamName = config[1]
    local colorParam = faceMakeupData[colorParamName]
    if value == 1 then 
        colorParam.y = 0
    else
        colorParam.y = 1
    end
    colorParam.z = 1
    faceMakeupData[colorParamName] = colorParam
end

-- 妆容，设置贴图位置偏移
function ComponentFaceMakeUp:SetBias(faceMakeupData, config, value)
    local colorParamName = config[1]
    local biasName = config[2]
    local colorParam = faceMakeupData[colorParamName]
    colorParam[biasName] = 1024 * value
    faceMakeupData[colorParamName] = colorParam
end

function ComponentFaceMakeUp:SetFaceMakeupValue(makeupType, value, iLatitudeType, iMakeupID)
    -- Logger.LogDebug("makeupType====" .. makeupType )
    if iLatitudeType then
        local tabSliderRange = MakeupController.model:GetSilderRange(iMakeupID, iLatitudeType)
        if tabSliderRange and next(tabSliderRange) ~= nil then
            value = value * (tabSliderRange.max - tabSliderRange.min) + tabSliderRange.min
        else
            value = 0
        end
    end
    local faceMakeupData = self.m_Owner.m_Core:GetFaceMakeupData()
    -- 设置材质属性，合图属性
    local valueTypeConfig = MakeUpDefine.SetOriginalValueType[makeupType]
    if valueTypeConfig then
        self:SetMakeupDataPropertyValue(valueTypeConfig, value)
    end

    -- 设置合图贴图
    local textureTypeConfig = MakeUpDefine.SetTextureType[makeupType]
    if textureTypeConfig then 
        self:SetTextureValueByConfig(faceMakeupData, textureTypeConfig, value)
    end

    -- 设置染色颜色
    local setDyeColorConfig = MakeUpDefine.SetDyeColorType[makeupType]
    if setDyeColorConfig then 
        self:SetDyeColor(faceMakeupData, setDyeColorConfig, value)
    end

    -- 妆容，设置染色强度
    local setDyeColorIntensityConfig = MakeUpDefine.SetDyeColorIntensityType[makeupType]
    if setDyeColorIntensityConfig then 
        self:SetDyeColorIntensity(faceMakeupData, setDyeColorIntensityConfig, value)
    end

    -- 设置染色开关
    local setDyeColorEnabledConfig = MakeUpDefine.SetDyeColorEnabledType[makeupType]
    if setDyeColorEnabledConfig then 
        self:SetDyeColorEnabled(faceMakeupData, setDyeColorEnabledConfig, value)
    end

    -- 设置合图bias
    local setBiasConfig = MakeUpDefine.SetBiasType[makeupType]
    if setBiasConfig then 
        self:SetBias(faceMakeupData, setBiasConfig, value)
    end

    --------------------------------------- 修容 -----------------------------------------
    if makeupType   == MakeUpDefine.MakeupEditType.Spot_Density then                -- 斑 疏密
        faceMakeupData:SetSpotBias(self.spotBiasBase.x * (1+value), self.spotBiasBase.y * (1+value), self.spotBiasBase.z, self.spotBiasBase.w)
    elseif makeupType   == MakeUpDefine.MakeupEditType.Mole_Scale then                  -- 痣 疏密
        local curMoleBias = faceMakeupData.moleBias
        -- value 范围0~1 对应调整花钿缩放范围 0~2
        faceMakeupData:SetMoleBias(self.moleBiasBase.x * value * 2, self.moleBiasBase.y * value * 2, curMoleBias.z, curMoleBias.w)
    --------------------------------------- 眉毛 -----------------------------------------
    elseif makeupType   == MakeUpDefine.MakeupEditType.Eyebrow_Tex then                 -- 眉毛 纹理
        self:SetTextureValue(faceMakeupData, 9, value, "tex_role_eyebrowbg_", "_d")
        local tab = string.split(faceMakeupData.partTexName[9], "_")
        local iID = tonumber(tab[#tab-1]) or 0
        faceMakeupData:SetEyebrowbgColorParam(MakeupController.model:GetLuminance(iID), faceMakeupData.eyebrowbgColorParam.y, faceMakeupData.eyebrowbgColorParam.z, faceMakeupData.eyebrowbgColorParam.w)
    --------------------------------------- 花钿 -----------------------------------------
    elseif makeupType   == MakeUpDefine.MakeupEditType.Tattoo_TattooScale then          -- 花钿 花钿缩放
        local curTattooBias = faceMakeupData.tattooBias
        -- value 范围0~1 对应调整花钿缩放范围 0~2
        faceMakeupData:SetTattooBias(self.tattooBiasBase.x * value * 2, self.tattooBiasBase.y * value * 2, curTattooBias.z, curTattooBias.w)
    end
end

function ComponentFaceMakeUp:GetFaceMakeupData()
    if not self.m_Owner then
        return
    end
    return self.m_Owner.m_Core:GetFaceMakeupData()
end

function ComponentFaceMakeUp:ChangeGender(gender)
    if not self.m_Owner then
        return
    end

    self.gender = gender
    self.m_Owner.m_Core:ChangeSexID(gender - 1)
end

function ComponentFaceMakeUp:InitPinchData()
    if self.m_ScriptableObject == nil then 
        ResourceManager.LoadScriptableObjectAsync(k_MakeUpConfigKey, function (scriptableObject, object)
            self.m_ScriptableObject = scriptableObject

            if not self.m_Owner then
                return
            end
            return self.m_Owner.m_Core:InitPinchData(self.m_ScriptableObject)
        end)
    end
end

-- 获取MeshRender
function ComponentFaceMakeUp:GetSkinedMeshRender(renderName)
    if not self.m_Owner then
        return
    end
    return self.m_Owner.m_Core:GetSkinedMeshRender(renderName)
end

-- 获取烘焙的Mesh
function ComponentFaceMakeUp:GetBakeMesh(renderName)
    if not self.m_Owner then
        return
    end
    return self.m_Owner.m_Core:GetBakeMesh(renderName)
end

-- 将网格烘焙到目标网格
function ComponentFaceMakeUp:BakeFaceMesh(renderName, skinedMeshRender, bakeMesh)
    if not self.m_Owner then
        return
    end
    return self.m_Owner.m_Core:BakeFaceMesh(renderName, skinedMeshRender, bakeMesh)
end

return ComponentFaceMakeUp