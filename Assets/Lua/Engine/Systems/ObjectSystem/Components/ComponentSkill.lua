---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/9/14 20:03
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local SkillConfigData = require("MainGame/ConfigData/SkillConfigData")
local BattleMessage = require("MainGame/Message/BattleMessage")
local SkillFactory = require("Engine/Systems/ObjectSystem/Skill/SkillFactory")
local ComponentSkill = class("ComponentSkill", ComponentBase)
local StateDefine = SGEngine.Core.StateDefine
local MoveSyncType = ComponentDefine.MoveSyncType
ComponentSkill.m_ComponentId = ComponentDefine.ComponentType.k_ComponentSkill

function ComponentSkill:Init(object)
    ComponentSkill.__super.Init(self, object)
    self.m_SkillCDMap = {}
    self.m_WillCDSkillMap = {}
end

function ComponentSkill:Destroy()
    self.m_SkillCDMap = nil
    self.m_WillCDSkillMap = nil
    ComponentSkill.__super.Destroy(self)
end

function ComponentSkill:Reset()
    self.m_WillCDSkillMap = {}
end

function ComponentSkill:UseSkill(skillId)
    if not skillId then
        return
    end
    if not self:CanUseSkill(skillId) then
        --Logger.LogInfo("Can't Use skill:"..skillId)
        return
    end
    --Logger.LogInfo("Use skill :%s. frame:%s", skillId, Time.frameCount)
    local skillTargetComponent = self.m_Owner.m_SkillTargetComponent
    if skillTargetComponent then
        skillTargetComponent:TrySearchTarget(false)
    end
    self:RawUseSkill(skillId)
end

function ComponentSkill:DeserializeSkillConfig(netBuffer)
    for i = 1, 2 do
        for j = 1, 8 do
            local LogInfo = netBuffer:ReadInt()
        end
    end
    local current_skill_group_ = netBuffer:ReadUByte()
end

function ComponentSkill:DeserializeSkillInfo(netBuffer)
    local count = netBuffer:ReadUByte()
    for i = 1, count do
        local skill_id = netBuffer:ReadInt()
        local skill_level = netBuffer:ReadUByte()
    end
end

function ComponentSkill:RawUseSkill(skillId)
    if not skillId then
        return
    end
    local owner = self.m_Owner
    local config = SkillConfigData:Get(skillId)
    if not config then
        Logger.LogErrorFormat("[Lua:ComponentSkill]:UseSkill null config , id:{0}", skillId)
        return
    end
    local skill = SkillFactory.CreateSkill(config.SkillModule, owner:IsHero())
    if skill then
        local targetObjectId = 0
        if owner.m_SkillTargetComponent ~= nil then
            targetObjectId = owner.m_SkillTargetComponent:GetTargetId()
        end
        local stateData = owner.m_StateComponent.m_StateSkillParam
        local currentSkill = stateData.m_CurrentSkill
        ---todo 这里手动调用一次OnSkillEnd，并在之后赋值lua 的currentSkill，主要是为了c#和lua 的时序问题
        if currentSkill ~= nil then
            local state = owner:GetState(StateDefine.k_StateSkill)
            state.OnSkillEnd(owner, currentSkill.m_Config.ID)
        end
        --Logger.LogInfo("SetCurrentSkill: %s, frame:%s", config.ID, Time.frameCount)
        stateData.m_CurrentSkill = skill
        skill:SetValid(false)
        skill:Init(owner, config, targetObjectId)
    end
end

function ComponentSkill:RawUseSkillBySyncInfo(skillId, targetObjectId, syncInfo)
    local owner = self.m_Owner
    --Logger.LogInfo("RawUseSkillBySyncInfo. objId: %s , skillId: %s, frame:%s", owner:GetObjectID(), skillId, Time.frameCount)
    targetObjectId = targetObjectId or 0
    if owner == nil then
        return
    end
    if not skillId then
        return
    end
    local config = SkillConfigData:Get(skillId)
    if not config then
        Logger.LogErrorFormat("[Lua:ComponentSkill]:UseSkill null config , id:{0}", skillId)
        return
    end
    local skill = SkillFactory.CreateSkill(config.SkillModule, self.m_Owner:IsHero())
    if skill then
        local stateData = owner.m_StateComponent.m_StateSkillParam
        local currentSkill = stateData.m_CurrentSkill
        ---todo 这里手动调用一次Destroy，并在之后赋值lua 的currentSkill，主要是为了c#和lua 的时序问题
        if currentSkill ~= nil then
            currentSkill:Destroy()
        end
        stateData.m_CurrentSkill = skill
        syncInfo.m_SyncType = MoveSyncType.k_SkillMoveStop
        skill:Init(owner, config, targetObjectId)
        skill:UpdateSyncInfo(syncInfo)
    end
end

---UI显示的CD
function ComponentSkill:AddSkillCD(skillId, offset)
    if not skillId then
        return
    end

    offset = offset or 0
    local config = SkillConfigData:Get(skillId)
    if not config then
        return
    end
    local skillCdInfo = self.m_SkillCDMap[skillId]
    if not skillCdInfo then
        skillCdInfo = {}
    end
    skillCdInfo.m_StartTime = os.time()
    skillCdInfo.m_EndTime = os.time() + config.CoolDown + offset
    self.m_SkillCDMap[skillId] = skillCdInfo
    self.m_WillCDSkillMap[config.StartSkillID] = 0

    local controller = ActionController
    local time = self:GetRemainCD(skillId)
    controller.ShowSkillCD(skillId, time)
end

function ComponentSkill:GetRemainCD(skillId)
    if not skillId then
        return 0
    end
    local LogInfo = self.m_SkillCDMap[skillId]
    if not LogInfo then
        return 0
    end

    return math.max(0, LogInfo.m_EndTime - os.time())
end

function ComponentSkill:IsSkillInCD(skillId)
    local remainCD = self:GetRemainCD(skillId)
    local willCD = false
    if self.m_WillCDSkillMap and self.m_WillCDSkillMap[skillId] == 1 then
        willCD = true
    end
    return remainCD > 0 or willCD
end

function ComponentSkill:GetCurrentSkillConfig()
    local stateData = self.m_Owner.m_StateComponent.m_StateSkillParam
    local currentSkill = stateData.m_CurrentSkill
    if not currentSkill then
        return nil
    end
    return currentSkill.m_Config
end

function ComponentSkill:GetCurrentSkill()
    local stateData = self.m_Owner.m_StateComponent.m_StateSkillParam
    local currentSkill = stateData.m_CurrentSkill
    if not currentSkill then
        return nil
    end
    return currentSkill
end

function ComponentSkill:CanUseSkill(skillId)
    if not skillId then
        return false
    end
    if self:IsSkillInCD(skillId) == true then
        return false
    end

    if not self:CheckState() then
        return false
    end

    local currentSkill = self:GetCurrentSkill()
    if currentSkill and currentSkill:IsBreakable() == false then
        return false
    end

    return true
end

function ComponentSkill:CheckState()
    if self.m_Owner:CanChangeState(StateDefine.k_StateSkill) == true then
        return true
    end

    return false
end

function ComponentSkill:OnStateSkillMove(posX, posY, posZ, angle, syncType)
    if not self.m_Owner then
        return
    end

    if self.m_Owner:IsState(StateDefine.k_StateSkill) then
        local state = self.m_Owner:GetState(StateDefine.k_StateSkill)
        if state ~= nil then
            state.OnStateSkillMove(self.m_Owner, posX, posY, posZ, angle, syncType)
        end
    end
end

function ComponentSkill:OnSkillStart(config)
    if not config then
        return
    end

    local startSkillConfig
    if config.StartSkillID == config.ID then
        startSkillConfig = config
    else
        startSkillConfig = SkillConfigData:Get(config.StartSkillID)
    end

    if startSkillConfig and startSkillConfig.CoolDown > 0 and config.IsComboEnd then
        self.m_WillCDSkillMap[config.StartSkillID] = 1
    end
end

function ComponentSkill:OnSkillRearSwing(config)
end

function ComponentSkill:OnSkillEnd(config)
    if not config then
        return
    end

    if not self.m_Owner then
        return
    end

    if self.m_Owner:IsHero() and config.IsInCombo == false then
        self:AddSkillCD(config.ID)
    end
end

return ComponentSkill