---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/9/17 11:44
---
local ComponentSkillCombo = class("ComponentSkillCombo", ComponentBase)
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local SkillConfigData = require("MainGame/ConfigData/SkillConfigData")
ComponentSkillCombo.m_ComponentId = ComponentDefine.ComponentType.k_ComponentSkillCombo
local StateDefine = SGEngine.Core.StateDefine
function ComponentSkillCombo:Init(object)
    ComponentSkillCombo.__super.Init(self, object)
    self.m_NextSkillId = nil
    self.m_CurrentComboConfig = nil
end

function ComponentSkillCombo:Destroy()
    ComponentSkillCombo.__super.Destroy(self)
    self.m_NextSkillId = nil
    self.m_CurrentComboConfig = nil
end

function ComponentSkillCombo:DoSkillCombo(skillId, targetObjectId, targetPosition)
    local owner = self.m_Owner
    local AnimationEventDefines = SGEngine.Core.AnimationEventDefines
    local currentComboConfig = self.m_CurrentComboConfig
    if not currentComboConfig then
        --Logger.LogInfo("DoSkillCombo false 1,skillId: %s", skillId)
        return false
    end
    local newSkillConfig = SkillConfigData:Get(skillId)
    if not newSkillConfig then
        --Logger.LogInfo("DoSkillCombo false 2,skillId: %s", skillId)
        return false
    end
    ---如果当前正在释放的技能不是一个起手技能
    if currentComboConfig.StartSkillID ~= nil then
        ---如果新技能不是当前技能的起始技能，并且他们属于不同的起始技能， 那就不接受连招
        if newSkillConfig.ID ~= currentComboConfig.StartSkillID and newSkillConfig.StartSkillID ~= currentComboConfig.StartSkillID then
            --Logger.LogInfo("DoSkillCombo false 3, newSkillConfig.ID:%s, currentComboConfig.StartSkillID: %s, newSkillConfig.StartSkillID: %s",
            --        newSkillConfig.ID, currentComboConfig.StartSkillID, newSkillConfig.StartSkillID)
            return false
        end
        ---如果当前正在释放的技能可能是一个起手技能
        ---那么只有两种情况会接受连招：1，新技能不是起手技且属于当前起手技；2，新技能就是当前技能
    else
        ---如果新技能不是一个起手技能，并且新技能不属于当前的起手技能， 不接受连招
        if newSkillConfig.StartSkillID ~= nil and newSkillConfig.StartSkillID ~= currentComboConfig.ID then
            --Logger.LogInfo("DoSkillCombo false 4, currentComboConfig.ID:%s, newSkillConfig.StartSkillID: %s",
            --        currentComboConfig.ID, newSkillConfig.StartSkillID)
            return false
            ---如果新技能可能是一个起手技能，并且不是当前技能
        elseif newSkillConfig.StartSkillID == nil and newSkillConfig.ID ~= currentComboConfig.ID then
            --Logger.LogInfo("DoSkillCombo false 5, currentComboConfig.ID:%s, newSkillConfig.StartSkillID: %s, newSkillConfig.ID:%s",
            --        currentComboConfig.ID, newSkillConfig.StartSkillID, newSkillConfig.ID)
            return false
        end
    end

    if not currentComboConfig.ComboConfig then
        --Logger.LogInfo("DoSkillCombo false 6,skillId: %s", skillId)
        return false
    end

    local nextSkillId
    ---如果a.新技能是当前技能的起手技，b.如果新技能就是当前技能，c.如果新技能是上一个接收的连招技能，以当前技能的Next继续
    ---例如连招1234
    ---a情况：用户输入为12，接1时，结果为123
    ---b情况：用户输入为13，接3时，结果为134
    ---c情况：用户输入为132，接22时结果为13234
    if skillId == currentComboConfig.StartSkillID or skillId == currentComboConfig.ID or self.m_LastNewSkillId == skillId then
        nextSkillId = currentComboConfig.ComboConfig:Random()
    else
        nextSkillId = skillId
    end

    if not nextSkillId then
        --Logger.LogInfo("DoSkillCombo false 7,skillId: %s", skillId)
        return false
    end
    self.m_LastNewSkillId = skillId

    local currentSkillConfig = owner.m_SkillComponent:GetCurrentSkillConfig()

    if currentSkillConfig ~= nil then
        if owner:IsSkillEventHandled(AnimationEventDefines.k_EventRearSwing) == false then
            if owner:IsSkillEventHandled(AnimationEventDefines.k_EventComboSwing) == true and not self.m_NextSkillId then
                --Logger.LogDebug("Add m_NextSkillId:" .. nextSkillId)
                self.m_NextSkillId = nextSkillId
            end
            --Logger.LogInfo("DoSkillCombo false 8,skillId: %s, self.m_NextSkillId: %s", skillId, self.m_NextSkillId)
            return false
        end
        Logger.LogDebug("ComboUseSkill1:" .. nextSkillId)
        owner.m_SkillComponent:UseSkill(nextSkillId, targetObjectId, targetPosition)
        return true
    else
        if self.m_ComboLeftTime ~= nil and self.m_ComboLeftTime > 0 then
            Logger.LogDebug("ComboUseSkill2:" .. nextSkillId)
            owner.m_SkillComponent:UseSkill(nextSkillId, targetObjectId, targetPosition)
            return true
        end
    end
    --Logger.LogInfo("DoSkillCombo false 9,skillId: %s", skillId)
    return false
end

function ComponentSkillCombo:Update(deltaTime)
    if self.m_ComboLeftTime then
        self.m_ComboLeftTime = self.m_ComboLeftTime - deltaTime
    end
    local config = self.m_CurrentComboConfig
    if config ~= nil and config.ComboConfig ~= nil and config.ComboConfig.ComboTime > 0 and self.m_ComboLeftTime ~= nil and self.m_ComboLeftTime < 0 then
        --Logger.LogDebug("UpdateClear")
        self:ClearCombo(config.ID)
    end
end

function ComponentSkillCombo:OnSkillStart(config)
    self.m_CurrentComboConfig = config
    self.m_ComboLeftTime = nil
end

function ComponentSkillCombo:OnSkillRearSwing()
    local owner = self.m_Owner
    local currentComboConfig = self.m_CurrentComboConfig
    if not currentComboConfig then
        return
    end
    local comboConfig = currentComboConfig.ComboConfig

    if self.m_NextSkillId then
        --Logger.LogDebug("Next1:" .. self.m_NextSkillId)
        owner.m_SkillComponent:UseSkill(self.m_NextSkillId)
        self.m_NextSkillId = nil
    elseif comboConfig then
        if self:CheckAutoCombo() then
            local nextSkillId = comboConfig:Random()
            --Logger.LogDebug("Next2:" .. nextSkillId)
            owner.m_SkillComponent:UseSkill(nextSkillId)
        else
            self.m_ComboLeftTime = comboConfig.ComboTime
            --Logger.LogInfo("Add EndTime:" .. tostring(self.m_ComboLeftTime))
        end
    end
end

function ComponentSkillCombo:OnSkillEnd(skillId, endByNewSkill)
    --Logger.LogInfo("ComponentSkillCombo:OnSkillEnd(skillId)" .. skillId)
    local currentComboConfig = self.m_CurrentComboConfig
    if currentComboConfig == nil then
        return
    end
    local comboConfig = currentComboConfig.ComboConfig
    --if currentComboConfig.IsComboEnd
    --        or (currentComboConfig.IsAutoCombo == false and comboConfig.ComboTime == 0)
    --        or self.m_Owner:IsNextState(StateDefine.k_StateSkill) == false then
    --    self:ClearCombo()
    --end

    if currentComboConfig.IsComboEnd then
        self:ClearCombo()
        return
    end

    if (currentComboConfig.IsAutoCombo == false and comboConfig.ComboTime == 0) then
        self:ClearCombo()
        return
    end

    local owner = self.m_Owner
    if owner:HasNextState() == true and owner:IsNextState(StateDefine.k_StateSkill) == false then
        self:ClearCombo()
        return
    end
end

function ComponentSkillCombo:CheckAutoCombo()
    local currentComboConfig = self.m_CurrentComboConfig
    return currentComboConfig.IsAutoCombo
end

function ComponentSkillCombo:ClearCombo()
    --Logger.LogDebug("ClearCombo")
    local owner = self.m_Owner
    local currentComboConfig = self.m_CurrentComboConfig
    owner.m_SkillComponent:AddSkillCD(currentComboConfig.StartSkillID)

    self.m_CurrentComboConfig = nil
    self.m_ComboLeftTime = nil
    self.m_NextSkillId = nil
end

return ComponentSkillCombo