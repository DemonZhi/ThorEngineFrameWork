---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/4/12 14:52
---
local ComponentSkillTarget = class("ComponentSkillTarget", ComponentBase)
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local SkillConfigData = require("MainGame/ConfigData/SkillConfigData")
local Time = Time
ComponentSkillTarget.m_ComponentId = ComponentDefine.ComponentType.k_ComponentSkillTarget

local k_SearchInterval = 0.5
local k_UpdateInterval = 0.1
local k_ClearTargetTimeInterval = 60
local k_RecoverWeightSpeed = 20
local k_MaxWeight = 100
local k_SearchTargetOffset = -3
local k_SearchAngle = 360
local k_SearchDistance = 20
local StateDefine = SGEngine.Core.StateDefine
local Core_EntityUtility = SGEngine.Core.EntityUtility

--region life
function ComponentSkillTarget:Init(object)
    ComponentSkillTarget.__super.Init(self, object)
    ---@type SGObject
    self.m_Target = nil
    self.m_LastUpdateTime = 0
    self.m_LastSearchTime = 0
    self.m_LockTarget = false
    self.m_IsChasing = false
    self.m_TargetLastTime = {}
    self.m_LastClearTargetTime = 0
end

function ComponentSkillTarget:Update()
    self:UpdateTarget()
    self:UpdateChase()
end
--endregion

--region public
-- 手动搜索目标、有则锁定
function ComponentSkillTarget:TrySearchTarget(needCheckRepeat)
    self:SetTarget(nil)
    self:SearchTarget(needCheckRepeat)
    self:SetLockTarget(self.m_Target ~= nil)
    return self.m_Target ~= nil
end

-- 获取目标ID
function ComponentSkillTarget:GetTargetId()
    if self.m_Target ~= nil then
        return self.m_Target:GetObjectID()
    end
    return 0
end

-- 锁定目标
function ComponentSkillTarget:LockTarget()
    if self.m_Target ~= nil then
        self:SetLockTarget(not self.m_LockTarget)
    end
end

-- 追击目标并释放技能
function ComponentSkillTarget:ChaseTargetAndPlaySkill(skillID)
    --Logger.LogInfo("ComponentSkillTarget:ChaseTargetAndPlaySkill:"..skillID)

    if self.m_IsChasing == true then
        return
    end

    local target = self.m_Target
    if target == nil then
        self.m_Owner:UseSkill(skillID)
        return
    end

    local ownerObjectID = self.m_Owner:GetObjectID()
    local targetObjectID = target:GetObjectID()
    local distance = Core_EntityUtility.GetDistanceBetweenObjects(targetObjectID, ownerObjectID)
    local config = SkillConfigData:Get(skillID)
    local attackRadius = math.max(1, config.AttackRadius)
    local targetRadius = target:GetRadius()
    local useSkillDistance = attackRadius + targetRadius
    if distance <= useSkillDistance or self.m_Owner:IsState(StateDefine.k_StateMove) then
        self.m_Owner:UseSkill(skillID)
        return
    end

    self.m_UseSkillDistance = useSkillDistance
    self.m_SqrUseSkillDistance = useSkillDistance * useSkillDistance
    self.m_CacheSkillID = skillID

    if not self.m_IsChasing then
        self.m_LastChasePosition = target:GetPosition()
        local succeed = self.m_Owner:ChangeToNavigateWithDestination(self.m_LastChasePosition)
        -- 找不到路径、释放技能好了
        if not succeed then
            Logger.LogInfoFormat("[ComponentSkillTarget](ChaseTargetAndPlaySkill) 找不到至目标的路径、直接释放技能")
            self.m_Owner:UseSkill(skillID)
            return
        end

        self.m_IsChasing = true
    end
end
--endregion

--region private
function ComponentSkillTarget:UpdateTarget()
    local currentTime = Time.time
    if currentTime - self.m_LastUpdateTime < k_UpdateInterval then
        return
    end

    self.m_LastUpdateTime = currentTime
    self:CheckTarget()

    -- 目标为空或非锁定时、需要检测是否有更高优先级的目标
    --if (self.m_Target == nil or not self.m_LockTarget) and currentTime - self.m_LastSearchTime > k_SearchInterval then
    --    self:SearchTarget(false)
    --end
end

function ComponentSkillTarget:UpdateChase()
    if not self.m_IsChasing then
        return
    end

    if not self.m_Target then
        self.m_IsChasing = false
        return
    end

    -- 因为update的先后关系、可能StateNavigate到目标点后、已经切回了Idle状态、此时需要继续追击
    if not self.m_Owner:IsState(StateDefine.k_StateNavigate) and not self.m_Owner:IsState(StateDefine.k_StateIdle) then
        self.m_IsChasing = false
        return
    end
    
    -- 追击过程中 目标已经在攻击范围
    local ownerObjectID = self.m_Owner:GetObjectID()
    local targetObjectID = self.m_Target:GetObjectID()
    local distance = Core_EntityUtility.GetDistanceBetweenObjects(targetObjectID, ownerObjectID)
    if distance < self.m_UseSkillDistance then
        self.m_IsChasing = false
        self.m_Owner:UseSkill(self.m_CacheSkillID)
        return
    end

    -- 目标当前位置与追击位置比攻击距离大、重新调整追击位置
    local position = self.m_Target:GetPosition():Clone()
    position:Sub(self.m_LastChasePosition)
    if position:SqrMagnitude() > self.m_SqrUseSkillDistance then
        self.m_LastChasePosition = self.m_Target:GetPosition()
        local succeed = self.m_Owner:ChangeToNavigateWithDestination(self.m_LastChasePosition)
        if not succeed then
            Logger.LogInfoFormat("[ComponentSkillTarget](UpdateChase) 找不到至目标的路径、停止追击")
            self.m_IsChasing = false
        end
        return
    end
end

function ComponentSkillTarget:ClearTargetTime()
    local currentTime = Time.time
    if currentTime - self.m_LastClearTargetTime < k_ClearTargetTimeInterval then
        return
    end
    self.m_LastClearTargetTime = currentTime

    for k, v in pairs(self.m_TargetLastTime) do
        if (currentTime - v) * k_RecoverWeightSpeed > k_MaxWeight then
            self.m_TargetLastTime[k] = nil
        end
    end
end

function ComponentSkillTarget:CheckTarget()
    if not self.m_Target then
        return
    end

    if self:IsValid(self.m_Target) == false then
        self:SetTarget(nil)
        return
    end

    local ownerObjectID = self.m_Owner:GetObjectID()
    local targetObjectID = self.m_Target:GetObjectID()
    if self:CheckAngle(targetObjectID, ownerObjectID) == false or self:CheckDistance(targetObjectID, ownerObjectID) == false then
        self:SetTarget(nil)
    end
end

function ComponentSkillTarget:SearchTarget(needCheckRepeat)
    self.m_LastSearchTime = Time.time
    local objectMap = ObjectManager.m_ObjectMap
    local ownerObjectID = self.m_Owner:GetObjectID()
    local minDistance = -1
    local maxWeight = 0
    local newTarget
    for i, v in pairs(objectMap) do
        repeat
            if not self:IsValid(v) then
                break
            end

            if v:GetObjectID() == ownerObjectID then
                break
            end

            local targetObjectID = v:GetObjectID()
            local isWithinDistance, distance = self:CheckDistance(targetObjectID, ownerObjectID)
            if not self:CheckAngle(targetObjectID, ownerObjectID) or not isWithinDistance then
                break
            end

            -- 权重优先级高、如相等才进行距离检测
            if needCheckRepeat then
                local targetWeight = self:GetTargetWeight(v)
                if targetWeight < maxWeight then
                    break
                elseif targetWeight > maxWeight then
                    minDistance = distance
                    maxWeight = targetWeight
                    newTarget = v
                    break
                end
            end

            if minDistance < 0 or minDistance > distance then
                minDistance = distance
                newTarget = v
                break
            end
        until true
    end

    if newTarget ~= self.m_Target then
        self:SetTarget(newTarget)
    end

    --if self.m_Target then
    --    local targetPosition = self.m_Target:GetPosition()
    --    SGEngine.Core.DebugDraw.DrawCircle(targetPosition, 0.2, UnityEngine.Color.red)
    --end
    return newTarget
end

function ComponentSkillTarget:CheckAngle(targetObjectID, ownerObjectID)
    local angle = Core_EntityUtility.GetAngleBetweenObjectAndForwardWithinXZ(ownerObjectID, targetObjectID)
    if angle <= k_SearchAngle then
        return true
    end

    return false
end

function ComponentSkillTarget:CheckDistance(targetObjectID, ownerObjectID)
    local distance = Core_EntityUtility.GetDistanceBetweenObjects(targetObjectID, ownerObjectID)
    local jobId = self.m_Owner.m_JobId
    local jobConfig = JobConfig[jobId]
    local checkDistance
    if not jobConfig then
        checkDistance = k_SearchDistance
    else
        checkDistance = jobConfig.SearchDistance
    end
    return distance <= k_SearchDistance, distance
end

function ComponentSkillTarget:IsValid(target)
    if target == nil then
        return false
    end

    local type = target.m_ObjectType
    if  type == nil or (type ~= ObjectTypeEnum.Player and type ~= ObjectTypeEnum.Monster and type ~= ObjectTypeEnum.Hero) then
        return false
    end

    if target == self.m_Owner then
        return false
    end

    if target:IsValid() == false then
        return false
    end

    if target:IsState(StateDefine.k_StateDead) then
        return false
    end

    if target:IsFriendly(target) then
        return false
    end

    return true
end

function ComponentSkillTarget:SetTarget(target)
    if self.m_LockTarget and self.m_Target ~= target then
        if self.m_Target and self.m_Target.m_HUDComponent then
            self.m_Target.m_HUDComponent:ActiveLockTargetFlag(false)
        end

        if target and target.m_HUDComponent then
            target.m_HUDComponent:ActiveLockTargetFlag(true)
        end
    end

    if target and self.m_Target ~= target then
        self.m_TargetLastTime[target:GetObjectID()] = Time.time
    end

    self.m_Target = target

    if target == nil then
        self:SetLockTarget(false)
    end
end

function ComponentSkillTarget:SetLockTarget(lock)
    self.m_LockTarget = lock

    if self.m_Target and self.m_Target.m_HUDComponent then
        self.m_Target.m_HUDComponent:ActiveLockTargetFlag(lock)
    end
end

function ComponentSkillTarget:GetTargetWeight(target)
    if not target then
        return 0
    end

    local lastTime = self.m_TargetLastTime[target:GetObjectID()]
    if not lastTime then
        return k_MaxWeight
    end

    local weight = (Time.time - lastTime) * k_RecoverWeightSpeed
    if weight > k_MaxWeight then
        weight = k_MaxWeight
    end

    return weight
end
--endregion

return ComponentSkillTarget