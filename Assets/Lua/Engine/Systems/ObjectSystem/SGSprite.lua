---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/6/29 11:00
---
local SGCtrl = require("Engine/Systems/ObjectSystem/SGCtrl")
local SGSprite = class("SGSprite", SGCtrl)
local DamageTextManager = SGEngine.UI.DamageTextManager.Instance
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local BattleMessage = require("MainGame/Message/BattleMessage")
local StateConsts = require("Engine/Systems/ObjectSystem/State/StateConsts")
local EventDefine = require("Engine/UI/Event/EventDefine")
local DamageConfigData = require("MainGame/ConfigData/DamageConfigData")
local SkillConfigData = require("MainGame/ConfigData/SkillConfigData")
local EffectConfig = require("Engine/Systems/EffectSystem/EffectConfig")

local MoveType = ComponentDefine.MoveType
local JumpType = ComponentDefine.JumpType
local StateDefine = SGEngine.Core.StateDefine
local StateReturnCode = SGEngine.Core.StateReturnCode
local BattleState = StateConsts.BattleStatus
local SkillType = SGEngine.Core.SkillDefines

SGSprite.m_ObjectType = ObjectTypeEnum.Sprite
SGSprite.New = nil
SGSprite.Create = nil

local k_DamageTextOffSet = Vector3.New(0, 1.5, 0)
function SGSprite:Ctor()
    SGSprite.__super.Ctor(self)
    self.m_BattleState = BattleState.OffBattle
    self.m_BattleStateLeftTime = 0
    self.m_CampId = nil
end

function SGSprite:Destroy()
    SGSprite.__super.Destroy(self)
    self.m_EffectComponent = nil
    self.m_EffectAmountControlComponent = nil
    self.m_FightResultComponent = nil
    self.m_PlaySpeedControlComponent = nil
    self.m_EventDispatcherComponent = nil
    self.m_SkillComponent = nil
    self.m_StateComponent = nil
    self.m_ModelPostProcessComponent = nil
end

function SGSprite:Deserialize(netBuffer)
    SGSprite.__super.Deserialize(self, netBuffer)

    local campId = netBuffer:ReadUByte()
    local level = netBuffer:ReadUShort()
    local hp = netBuffer:ReadInt()
    local maxHp = netBuffer:ReadInt()
    local moveSpeed = netBuffer:ReadInt()

    ---buff_mgr_COM.unserialize();
    self:DeserializeBuff(netBuffer)
    ---unserialize_sfx();
    self:DeserializeEffect(netBuffer)

    self.m_AttrComponent:SetAttribute(ComponentDefine.AttributeDefine.k_Hp, hp)
    self.m_AttrComponent:SetAttribute(ComponentDefine.AttributeDefine.k_MaxHp, maxHp)
    self.m_CampId = campId
end

function SGSprite:DeserializeBuff(netBuffer)
    local count = netBuffer:ReadUByte()
    for i = 1, count do
        local caster_id = netBuffer:ReadInt()
        local buff_sn = netBuffer:ReadInt()
        local buff_id = netBuffer:ReadInt()
        local buff_time = netBuffer:ReadInt()
        local client_param_count = netBuffer:ReadInt()
        for j = 1, client_param_count do
            local effect_id = netBuffer:ReadInt()
            local param_count = netBuffer:ReadInt()
            for k = 1, param_count do
                local param = netBuffer:ReadInt()
            end
        end
    end
end

function SGSprite:DeserializeEffect(netBuffer)
    local count = netBuffer:ReadInt()
    if count <= 0 then
        return
    end

    local effectId
    for i = 1, count do
        effectId = netBuffer:ReadInt()
    end
end

function SGSprite:SetModel(go, animationType)
    self.m_CurrentAnimationNames = {}
    SGSprite.__super.SetModel(self, go, animationType)
end

function SGSprite:ResetModel(gameObject)
    self.m_CurrentAnimationNames = {}
    SGSprite.__super.ResetModel(self, gameObject)
end

function SGSprite:RegisterCommonComponents()
    --缓存的每一个Component务必在Destroy的时候置空
    self.m_EffectComponent = ComponentEffect.New()
    self:AddComponent(self.m_EffectComponent, true)
    self.m_EffectAmountControlComponent = ComponentEffectAmountControl.New()
    self:AddComponent(self.m_EffectAmountControlComponent, false)
    self.m_FightResultComponent = ComponentFightResult.New()
    self:AddComponent(self.m_FightResultComponent, false)
    self.m_FightResultRecordComponent = ComponentFightResultRecorder.New()
    self:AddComponent(self.m_FightResultRecordComponent, false)
    self.m_PlaySpeedControlComponent = ComponentPlaySpeedControl.New()
    self:AddComponent(self.m_PlaySpeedControlComponent, false)
    self.m_EventDispatcherComponent = ComponentEventDispatcher.New()
    self:AddComponent(self.m_EventDispatcherComponent, false)
    self.m_StateComponent = ComponentState.New()
    self:AddComponent(self.m_StateComponent, true)
    self.m_SkillComponent = ComponentSkill.New()
    self:AddComponent(self.m_SkillComponent, false)
    self.m_AttrComponent = ComponentAttribute.New()
    self:AddComponent(self.m_AttrComponent, false)

    self.m_ModelPostProcessComponent = ComponentModelPostProcess.New()
    self:AddComponent(self.m_ModelPostProcessComponent, false)
    self.m_LoadModelQueueComponent = ComponentLoadModelQueue.New()
    local isHero = self:IsHero()
    self:AddComponent(self.m_LoadModelQueueComponent, isHero == false)
end

function SGSprite:RegisterModelEvents()
    SGSprite.__super.RegisterModelEvents(self)
end

-- 子类复写具体逻辑 然后再调用父类方法
--region 状态切换接口
function SGSprite:SetState(stateDefine,...)
    self.m_Core:SetState(stateDefine,...)
end

function SGSprite:DelState(stateDefine, ...)
    return self.m_Core:DelState(stateDefine, ...)
end
--region 移动接口

-----主角移动接口,非移动状态时调用会先进入移动状态
------@param   direction 方向
-----@param   isSprint   是否冲刺
function SGSprite:Move(direction, isSprint)
    if self:IsHero() == false then
        return
    end

    if isSprint and self:IsServerInFightState() == true then
        return
    end
    self.m_MoveComponent:Move(direction, isSprint)
end
-----主角移动接口,单纯切状态
function SGSprite:ChangeToMove(direction, isSprint)
    if self:IsHero() == false then
        return
    end
    isSprint = isSprint or false
    if isSprint and self:IsServerInFightState() == true then
        return
    end
    self.m_StateComponent.m_StateMoveParam.m_IsSprint = isSprint
    self.m_Core:ChangeToMove(direction)
end

function SGSprite:StopMove(isSprint)
    isSprint = isSprint or false
    self.m_MoveComponent:StopMove(isSprint)
end
--endregion

function SGSprite:ChangeToDead(posX, posY, posZ, angle, ignoreStateCheck)
    local stateHitFloatParam = self.m_StateComponent.m_StateHitFloatParam
    if not ignoreStateCheck and stateHitFloatParam.m_NeedCacheDead then
        local deadParam = {}
        stateHitFloatParam.m_DeadParam = deadParam
        deadParam.m_PosX = posX
        deadParam.m_PosY = posY
        deadParam.m_PosZ = posZ
        deadParam.m_Angle = angle
    else
        if posX ~= nil and angle ~= nil then
            self:SetPositionXYZ(posX, posY, posZ)
            self:SetAngle(angle)
        end
        self.m_Core:ChangeToDead()
    end
end

function SGSprite:ChangeToCinema(animationName)
    if self.m_Core == nil then
       return 
    end
    self:StopMove()
    self.m_StateComponent.m_StateCinemaParam.m_CinemaAnim = animationName
    self.m_Core:ChangeToCinema()
end

function SGSprite:ChangeToIdle()
    if self.m_Core == nil then
       return
    end
    self.m_Core:ChangeToIdle()
end

function SGSprite:ChangeToHit(hitType, duration, destination, speed, angle)
    local param = self.m_StateComponent.m_StateHitParam
    param.m_HitType = hitType
    param.m_ServerDuration = duration
    param.m_Destination = destination
    param.m_Speed = speed
    param.m_Angle = angle
    self.m_Core:ChangeToHit()
end

function SGSprite:ChangeToHitFloat(hitType, duration, destination, speed, angle)
    local param = self.m_StateComponent.m_StateHitFloatParam
    param.m_HitType = hitType
    param.m_ServerDuration = duration
    param.m_Destination = destination
    param.m_Speed = speed
    param.m_Angle = angle
    self.m_Core:ChangeToHitFloat()
end

function SGSprite:ChangeToPull(duration, targetPosX, targetPosY, targetPosZ, speed)
    local param = self.m_StateComponent.m_StatePullParam
    param.m_Duration = duration
    param.m_TargetPosX = targetPosX
    param.m_TargetPosY = targetPosY
    param.m_TargetPosZ = targetPosZ
    param.m_Speed = speed
    self.m_Core:ChangeToPull()
end

function SGSprite:ChangeToRide(rideId)
    self.m_Core:ChangeToRide(rideId)
end

function SGSprite:StopRide()
    self.m_Core:StopRide()
end

function SGSprite:ChangeToJump()
    local moveType = self.m_MoveComponent:GetCurrentMoveType()
    local config = self:GetCharacterConfig()
    local speedXZ = 0
    local height = 0

    if self:IsState(StateDefine.k_StateSkill) then
        local skill = self.m_SkillComponent:GetCurrentSkill()
        if skill:IsBreakable() == false then
            return
        end
    end
    
    if self:IsState(StateDefine.k_StateRide) then
        local mountConfig = self.m_StateComponent.m_StateRideParam.m_MountConfig
        height = mountConfig.JumpHeight
        speedXZ = mountConfig.JumpSpeed
    else
        local attributeDefine = ComponentDefine.AttributeDefine
        if moveType == MoveType.Run or moveType == MoveType.RunStop then
            speedXZ = self.m_AttrComponent:GetAttribute(attributeDefine.k_MoveSpeed)
            height = config.JumpHeight
        elseif moveType == MoveType.Sprint or moveType == MoveType.SprintStop or moveType == MoveType.SprintTurn or moveType == MoveType.SprintStopRearSwing then
            speedXZ = self.m_AttrComponent:GetAttribute(attributeDefine.k_SprintSpeed)
            height = config.SprintJumpHeight
        elseif moveType == MoveType.None then
            speedXZ = 0
            height = config.JumpHeight
        end
    end

    self.m_StateComponent.m_StateJumpParam.m_SpeedXZ = speedXZ
    self.m_StateComponent.m_StateJumpParam.m_JumpHeight = height
    self.m_Core:ChangeToJump()
end

function SGSprite:ChangeToFall()
    local attributeDefine = ComponentDefine.AttributeDefine
    local moveType = self.m_MoveComponent:GetCurrentMoveType()
    local speedXZ = self.m_AttrComponent:GetAttribute(attributeDefine.k_MoveSpeed)
    if self:IsState(StateDefine.k_StateRide) then
        local mountConfig = self.m_StateComponent.m_StateRideParam.m_MountConfig
        speedXZ = mountConfig.JumpSpeed
    else
        if moveType == MoveType.Sprint then
            speedXZ = self.m_AttrComponent:GetAttribute(attributeDefine.k_SprintSpeed)
        elseif moveType == MoveType.None then
            speedXZ = 0
        end
    end
    self.m_StateComponent.m_StateJumpParam.m_SpeedXZ = speedXZ
    self.m_StateComponent.m_StateJumpParam.m_JumpHeight = 0
    self.m_Core:ChangeToJump()
end

---@param stateDef int
function SGSprite:CanChangeState(stateDef)
    return self.m_Core:CanChangeState(stateDef)
end

function SGSprite:ChangeToDaze()
    self.m_Core:ChangeToDaze()
end

function SGSprite:ChangToCaught(attackObjID, configID)
    local stateCaughtParam = self.m_StateComponent.m_StateCaughtParam
    stateCaughtParam.m_TargetObjID = attackObjID
    stateCaughtParam.m_ConfigID = configID
    self.m_Core:ChangeToCaught()
end

function SGSprite:ChangeToFreeze()
    self.m_Core:ChangeToFreeze()
end

function SGSprite:StopDaze()
    local result = self:DelState(StateDefine.k_StateDaze)
    if result == StateReturnCode.OK then
        return
    end
    local fightResultRecordComponent = self.m_FightResultRecordComponent
    if not fightResultRecordComponent then
        return
    end

    local fightResult = fightResultRecordComponent:GetRecordedFightResultByType(ComponentDefine.FightResultType.k_Daze)
    if not fightResult then
        return
    end

    local attackObjectId = fightResult.m_AttackObjectId
    local attackObject = ObjectManager.GetObject(attackObjectId)
    if attackObject and attackObject.m_FightResultComponent then
        attackObject.m_FightResultComponent:RemoveFightResult(fightResult)
    end
    fightResultRecordComponent:RemoveFightResult(fightResult)
end

function SGSprite:StopCaught()
    local result = self:DelState(StateDefine.k_StateCaught)
    if result == StateReturnCode.OK then
        return
    end
    local fightResultRecordComponent = self.m_FightResultRecordComponent
    if not fightResultRecordComponent then
        return
    end

    local fightResult = fightResultRecordComponent:GetRecordedFightResultByType(ComponentDefine.FightResultType.k_Caught)
    if not fightResult then
        return
    end

    local attackObjectId = fightResult.m_AttackObjectID
    local attackObject = ObjectManager.GetObject(attackObjectId)
    if not attackObject then
        return
    end
    local fightResultComponent = attackObject.m_FightResultComponent
    if not fightResultComponent then
        return
    end
    fightResultComponent:RemoveFightResult(fightResult)
    fightResultRecordComponent:RemoveFightResult(fightResult)
end

function SGSprite:StopFreeze()
    local result = self:DelState(StateDefine.k_StateFreeze)
    if result == StateReturnCode.OK then
        return
    end
    local fightResultRecordComponent = self.m_FightResultRecordComponent
    if not fightResultRecordComponent then
        return
    end

    local fightResult = fightResultRecordComponent:GetRecordedFightResultByType(ComponentDefine.FightResultType.k_Freeze)
    if not fightResult then
        return
    end

    local attackObjectId = fightResult.m_AttackObjectId
    local attackObject = ObjectManager.GetObject(attackObjectId)
    if attackObject and attackObject.m_FightResultComponent then
        attackObject.m_FightResultComponent:RemoveFightResult(fightResult)
    end
    fightResultRecordComponent:RemoveFightResult(fightResult)
end

--endregion

--region 运行时属性
--region ---Set
function SGSprite:SetCurrentMoveSpeed(value)
    --Logger.LogInfo("SetCurrentMoveSpeed:"..value)
    self.m_Core.CurrentMoveSpeed = value
end

function SGSprite:SetCurrentRotateSpeed(value)
    --Logger.LogInfo("SetCurrentRotateSpeed:"..value)
    self.m_Core.CurrentRotateSpeed = value
end

function SGSprite:SetCurrentMoveSpeedY(value)
    --Logger.LogInfo("SetCurrentMoveSpeedY:"..value)
    self.m_Core.CurrentMoveSpeedY = value
end

function SGSprite:SetCurrentGravity(value)
    --Logger.LogInfo("SetCurrentGravity:"..value)
    self.m_Core.CurrentGravity = value
end
--endregion

--region ---Get
function SGSprite:GetCurrentMoveSpeed()
    return self.m_Core.CurrentMoveSpeed
end

function SGSprite:GetCurrentRotateSpeed()
    return self.m_Core.CurrentRotateSpeed
end

function SGSprite:GetCurrentMoveSpeedY()
    return self.m_Core.CurrentMoveSpeedY
end

function SGSprite:GetCurrentGravity()
    return self.m_Core.CurrentGravity
end

function SGSprite:GetCurrentPlaySpeed()
    return self.m_Core.CurrentPlaySpeed
end

function SGSprite:GetMountPointTransform()
    return self.m_Core:GetMountPointTransform()
end

function SGSprite:GetStateTargetAngle(stateDefine)
    return self.m_Core:GetStateTargetAngle(stateDefine)
end

function SGSprite:SetStateTargetAngle(stateDefine, angle)
    self.m_Core:SetStateTargetAngle(stateDefine, angle)
end

function SGSprite:IsUseRootMotion()
    return self.m_Core:IsUseRootMotion()
end

function SGSprite:GetRootPosition()
    return self.m_Core:GetRootPosition()
end

function SGSprite:GetRootAngle()
    return self.m_Core:GetRootAngle()
end
--endregion
--endregion

function SGSprite:Update(deltaTime)
    SGSprite.__super.Update(self, deltaTime)
    self:UpdateBattleStatus(deltaTime)
end

---进入战斗接口
---必须调用BeginExitBattle才能退出
---@param beginTryExit 是否自动开始倒计时退出
function SGSprite:EnterBattle(beginTryExit, playAnimation)
    self.m_BattleStateLeftTime = 0
    if self.m_BattleState ~= BattleState.OnBattle then
        self.m_BattleState = BattleState.OnBattle
    end
    self.m_EventDispatcherComponent:Dispatch(EventDefine.k_OnBattle, self, playAnimation)
    if beginTryExit then
        self:BeginExitBattle(tonumber(GameSettings["RoleOffBattleTime"].Value))
    end
end

---开始退出战斗倒计时
---@param totalTime 总时间,为0 则直接触发Exit
function SGSprite:BeginExitBattle(totalTime)
    if totalTime == 0 then
        self:ExitBattle()
    else
        self.m_BattleStateLeftTime = totalTime
    end
end

function SGSprite:ExitBattle()
    if self.m_BattleState == BattleState.OffBattle then
        return
    end
    self.m_BattleState = BattleState.OffBattle
    self.m_EventDispatcherComponent:Dispatch(EventDefine.k_OffBattle, self)
end

function SGSprite:UpdateBattleStatus(deltaTime)
    if self.m_BattleStateLeftTime > 0 then
        self.m_BattleStateLeftTime = self.m_BattleStateLeftTime - deltaTime
        if self.m_BattleStateLeftTime < 0 then
            self:ExitBattle()
        end
    end
end

function SGSprite:IsOnBattle()
    return self.m_BattleState == BattleState.OnBattle
end

function SGSprite:SetServerFightState(isInFight)
    self.m_IsServerInFight = isInFight
    local isHero = self:IsHero()
    if isInFight then
        self:EnterBattle(false, true)
        if isHero then
            AlertController.ShowTips("进入战斗")
        end
    else
        self:ExitBattle()
        if isHero then
            AlertController.ShowTips("离开战斗")
        end
    end
end

function SGSprite:IsServerInFightState()
    return self.m_IsServerInFight
end

function SGSprite:IsUsingJumpSkill()
    if self:IsState(StateDefine.k_StateSkill) == false then
        return false
    end

    local config = self.m_SkillComponent:GetCurrentSkillConfig()
    if not config then
        return false
    end

    if config.SkillModule == SkillType.k_SkillTypeJump then
        return true
    end

    return false
end

function SGSprite:HandleDamage(attackSpriteId, damage, actionId, damageType)
    if self:GetModel() == nil then
        return
    end
    if damage <= 0 then
        return
    end
    --if not self:IsHero() then
        DamageTextManager:ShowDamageText("CommonAttack", damage, self:GetModel().transform, k_DamageTextOffSet)
    --end
    -- Logger.LogDebugFormat("HandleDamage attackSpriteId:{0},self:{1} damage:{2}  leftHp:{3}", attackSpriteId, actionId, damage, self.hp)

    self:PlayHurtHighlight(0)
    local damageConfig = DamageConfigData:Get(actionId)
    if damageConfig then
        local effects = damageConfig.EffectList
        if effects and #effects > 0 then
            local effectId = effects[math.floor(UnityEngine.Random.Range(1, #effects + 1))]
            local effectConfig = EffectConfig.Get(effectId)
            if effectConfig == nil then
                return
            end
            local effectAmountControlComponent = self.m_EffectAmountControlComponent
            if effectAmountControlComponent then
                local result = effectAmountControlComponent:TryRegisterEffect(effectId, effectConfig.m_BindPath)
                if result == false then
                    return
                end
            end
            self.m_EffectComponent:PlayNormalEffect(effectId)
        end
    end
    local sprite = ObjectManager.GetObject(attackSpriteId)
    if sprite and sprite.m_PlaySpeedControlComponent then
        sprite.m_PlaySpeedControlComponent:Attach(self)
    end
end

function SGSprite:ContainAnimation(animationName)
    if self.m_CurrentAnimationNames == nil then
        self.m_CurrentAnimationNames = {}
    end

    local result = self.m_CurrentAnimationNames[animationName]
    if not result then
        result = self.m_Core:ContainAnimation(animationName)
        self.m_CurrentAnimationNames[animationName] = result
    end
    return result
end

function SGSprite:ChangeToNavigateWithDestination(destination)
    if self:IsHero() then
        local pathData = SGEngine.Core.EntityUtility.CalculateNavPath(self:GetPosition(), destination)
        if pathData.Count < 2 then
            return false
        end

        local pathPoints = {}
        for i = 0, pathData.Count - 1 do
            table.insert(pathPoints, pathData[i])
        end

        self.m_StateComponent.m_StateNavigationParam.m_PathPoints = pathPoints
        self.m_Core:ChangeToNavigateWithPathPoints(pathData)
    else
        self.m_Core:ChangeToNavigateWithDestination(destination.x, destination.y, destination.z)
    end

    return true
end

function SGSprite:ChangeToNavigateWithNavMeshPath(navMeshPath)
    ---@param navMeshPath UnityEngine.AI.NavMeshPath
    self.m_Core:ChangeToNavigateWithNavMeshPath(navMeshPath)
end

function SGSprite:StopNavigate()
    self.m_Core:StopNavigate()
end

--region Navigate
---@param callback Action<bool>
function SGSprite:RegNavigateFinishCallback(callback)
    self.m_Core:RegNavigateFinishCallback(callback)
end
---@param callback Action<bool>
function SGSprite:UnRegNavigateFinishCallback(callback)
    self.m_Core:UnRegNavigateFinishCallback(callback)
end
--endregion

function SGSprite:UseSkill(skillId)
    if self.m_SkillComboComponent then
        if self.m_SkillComboComponent:DoSkillCombo(skillId) then
            return
        end
    end

    if not self.m_SkillComponent then
        return
    end
    self.m_SkillComponent:UseSkill(skillId)
end

function SGSprite:CanUseSkill(skillId)
    local skillComponent = self.m_SkillComponent

    if skillComponent then
        return skillComponent:CanUseSkill(skillId)
    end

    return false
end

function SGSprite:CanUseJumpSkill(skillId)
    if self:IsState(StateDefine.k_StateJump) and self.m_SkillComponent:IsSkillInCD(skillId) == false then
        return true
    end
    return false
end

function SGSprite:UseJumpSkill(skillId)
    BattleMessage.SendDeleteStateJump()
    self:DelState(StateDefine.k_StateJump)
    self:UseSkill(skillId)
end

function SGSprite:RawUseSkill(skillId)
    if not self.m_SkillComponent then
        return
    end
    self.m_SkillComponent:RawUseSkill(skillId)
end

function SGSprite:RawUseSkillBySyncInfo(skillId, targetObjectId, syncInfo)
    if not self.m_SkillComponent then
        return
    end
    self.m_SkillComponent:RawUseSkillBySyncInfo(skillId, targetObjectId, syncInfo)
end

function SGSprite:AddBehaviorTree(treeName, isAutoStart, finishCall)
    if isAutoStart == nil then
        isAutoStart = true
    end
    self.m_Core:AddBehaviorTree(treeName, isAutoStart, finishCall)
end

function SGSprite:StartBehaviorTree()
    self.m_Core:StartBehaviorTree()
end

function SGSprite:StopBehaviorTree()
    self.m_Core:StopBehaviorTree()
end

function SGSprite:AddDrag(invokerID, dragSpeed, effectSn, noiseX, noiseZ)
    local dragComponent = self.m_DragComponent
    if dragComponent == nil then
        dragComponent = ComponentDrag.New()
        self.m_DragComponent = dragComponent
        self:AddComponent(dragComponent, true)
    end
    dragComponent:AddDrag(invokerID, dragSpeed, effectSn, noiseX, noiseZ)
end

function SGSprite:RemoveDrag(effectSn)
    local dragComponent = self.m_DragComponent
    if dragComponent == nil then
        return
    end
    dragComponent:RemoveDrag(effectSn)
end

function SGSprite:SetJobSystemActive(active)
    --Logger.LogInfo("SetJobSystemActive:%s", tostring(active))
    self.m_Core:SetJobSystemActive(active)
end

function SGSprite:IsBehaviorTreeRunning()
    return self.m_Core:IsBehaviorTreeRunning()
end

function SGSprite:GetBehaviourTreeVariable(name)
    return self.m_Core:GetBehaviourTreeVariable(name)
end

function SGSprite:SetBehaviourTreeVariable(name, value)
    self.m_Core:SetBehaviourTreeVariable(name, value)
end

function SGSprite:SetBehaviourTreeVariable(table)
    self.m_Core:SetBehaviourTreeVariable(table)
end

function SGSprite:GetBehaviourTreeVariableObject(name)
    return self.m_Core:GetBehaviourTreeVariableObject(name)
end

function SGSprite:GetBehaviourTreeAllVariable()
    return self.m_Core:GetBehaviourTreeAllVariable()
end

function SGSprite:IsNextState(stateDefine)
    return self.m_Core:IsNextState(stateDefine)
end

function SGSprite:HasNextState()
    return self.m_Core:HasNextState()
end

function SGSprite:PlayHurtHighlight(hurtType)
    self.m_Core:PlayHurtHighlight(hurtType)
end

function SGSprite:PlayDeadDissolve(dissolveType)
    self.m_Core:PlayDeadDissolve(dissolveType)
end

function SGSprite:PlayIceFreeze(freezeType)
    self.m_Core:PlayIceFreeze(freezeType)
end

function SGSprite:IsState(state)
    return self.m_Core:IsState(state)
end

function SGSprite:IsLastState(state)
    return self.m_Core:IsLastState(state)
end

function SGSprite:GetState(stateDefine)
    return self.m_StateComponent:GetState(stateDefine)
end

function SGSprite:GetBodyPartTransform(name)
    return self.m_Core:GetBodyPartTransform(name)
end

function SGSprite:HasBodyPartTransform(name)
    return self.m_Core:HasBodyPartTransform(name)
end

function SGSprite:GetBodyPartTransformPositionXYZ(name)
    local x,y,z = 0
    return self.m_Core:GetBodyPartTransformPositionXYZ(name, x, y, z)
end

function SGSprite:GetBodyPartTransformRotationXYZW(name)
    local x,y,z,w = 0
    return self.m_Core:GetBodyPartTransformRotationXYZW(name, x, y, z, w)
end

function SGSprite:GetBodyPartTransformPositionX(name)
    return self.m_Core:GetBodyPartTransformPositionX(name)
end

function SGSprite:GetBodyPartTransformPositionY(name)
    return self.m_Core:GetBodyPartTransformPositionY(name)
end

function SGSprite:GetBodyPartTransformPositionZ(name)
    return self.m_Core:GetBodyPartTransformPositionZ(name)
end

function SGSprite:UnRegAnimationCallback(animationName)
    self.m_Core:UnRegAnimationCallback(animationName)
end

function SGSprite:IsSkillEventHandled(eventName)
    if not self.m_SkillComponent:GetCurrentSkillConfig() then
        --Logger.LogDebug("[SGSprite](IsSkillEventHandled) :Return false")
        return false
    end
    return self.m_Core:IsSkillEventHandled(eventName)
end

function SGSprite:SetAnimationPlaySpeed(speed)
    self.m_Core:SetAnimationPlaySpeed(speed)
end

function SGSprite:PredictMoveOnGroundByPhysics(angle, speed, stepCount)
    self.m_Core:PredictMoveOnGroundByPhysics(angle, speed, stepCount)
end

function SGSprite:PredictMoveByPhysics(angle, speed, stepCount)
    self.m_Core:PredictMoveByPhysics(angle, speed, stepCount)
end

function SGSprite:PredictMoveByPhysicsWithCurrentForward(speed, stepCount)
    self.m_Core:PredictMoveByPhysicsWithCurrentForward(speed, stepCount)
end

function SGSprite:PredictPosOnGroundStepByStepByControllerWithTargetAngle(moveSpeed, rotateSpeed, predictStepCount, targetAngle)
    local outAngle
    return self.m_Core:PredictPosOnGroundStepByStepByControllerWithTargetAngle(moveSpeed, rotateSpeed, predictStepCount, targetAngle, outAngle)
end

function SGSprite:PredictPosOnGround(angle, speed, stepCount)
    return self.m_Core:PredictPosOnGround(angle, speed, stepCount)
end

function SGSprite:PredictPosOnGroundByController(angle, speed, stepCount)
    return self.m_Core:PredictPosOnGroundByController(angle, speed, stepCount)
end

function SGSprite:PredictPosByController(angle, speed, step)
    return self.m_Core:PredictPosByController(angle, speed, step)
end

function SGSprite:PredictPosByControllerWithCurrentForward(speed, step)
    return self.m_Core:PredictPosByControllerWithCurrentForward(speed, step)
end

function SGSprite:CalculateNextPosWithTarget(moveSpeed, targetObjectId, isArrived, considerRadius, stepCount)
    if considerRadius == nil then
        considerRadius = true
    end
    stepCount = stepCount or 1
    return self.m_Core:CalculateNextPosWithTarget(moveSpeed, targetObjectId, isArrived, considerRadius, stepCount)
end

function SGSprite:FreezeAnimator()
    --Logger.LogInfo("SGSprite:FreezeAnimator")
    self.m_Core:FreezeAnimator()
    if self.m_EffectComponent then
        self.m_EffectComponent:FreezeActiveEffects()
    end
end

function SGSprite:UnFreezeAnimator()
    --Logger.LogInfo("SGSprite:UnFreezeAnimator")
    self.m_Core:UnFreezeAnimator()
    if self.m_EffectComponent then
        self.m_EffectComponent:UnFreezeActiveEffects()
    end
end

function SGSprite:GetCharacterConfig()
    local config = CharacterConfig[self.m_ResourceId]
    if config == nil then
        config = CharacterConfig[-1]
    end
    return config
end

function SGSprite:ChangeSkinAsync(changeSkinPartName, skinModelName, callBack, repairBonePath, newModelSkinPartNameMask)
    return self.m_Core:ChangeSkinAsync(changeSkinPartName, skinModelName, callBack, repairBonePath, newModelSkinPartNameMask)
end

function SGSprite:ChangeAllSkin(skinModelName, callBack, lodSuffix)
    return self.m_Core:ChangeAllSkin(skinModelName, callBack, lodSuffix)
end

function SGSprite:ChangeSkin(changeSkinPartName, skinModelPath, repairBonePath, newModelSkinPartNameMask)
    self.m_Core:ChangeSkin(changeSkinPartName, skinModelPath, repairBonePath, newModelSkinPartNameMask)   
end

function SGSprite:SetBodyPartActive(bodyPartName, active)
    self.m_Core:SetBodyPartActive(bodyPartName, active)
end

function SGSprite:SetBodyPartRenderActive(bodyPartName, active)
    self.m_Core:SetBodyPartRenderActive(bodyPartName, active)
end

function SGSprite:SetBodyPartActiveWithBlurSearch(bodyPartName, active)
    self.m_Core:SetBodyPartActiveWithBlurSearch(bodyPartName, active)
end

function SGSprite:SetBodyPartRenderActiveWithBlurSearch(bodyPartName, active)
    self.m_Core:SetBodyPartRenderActiveWithBlurSearch(bodyPartName, active)
end

function SGSprite:IsFriendly(otherSprite)
    return false
end

--region NetCall
function SGSprite:OnRevive()
    self:DelState(StateDefine.k_StateDead)
end
--endregion

function SGSprite:CheckAndAddMoveWave()

end

--------------------------------LineRender----------------
function  SGSprite:LoadLineRender(path, callback)
   if self.m_Core == nil then return end
   self.m_Core:LoadLineRender(path, callback)
end

function SGSprite:SetLineRenderPosition(position)
   if self.m_Core == nil then return end
   self.m_Core:SetLineRenderPosition(position)
end

function SGSprite:SetLineRenderPositions(positions)
   if self.m_Core == nil then return end
   self.m_Core:SetLineRenderPositions(positions) 
end

function SGSprite:SetLineRenderPositionByIndex(position, index)
   if self.m_Core == nil then return end
   self.m_Core:SetLineRenderPositionByIndex(position, index) 
end

function SGSprite:SetLineRenderColor(color)
   if self.m_Core == nil then return end
   self.m_Core:SetLineRenderColor(color)     
end

function SGSprite:ClearLineRenderPositions()
   if self.m_Core == nil then return end
   self.m_Core:ClearLineRenderPositions()
end

function SGSprite:GetLineRenderLastPosition()
   if self.m_Core == nil then return nil end
   return self.m_Core:GetLineRenderLastPosition()
end

function SGSprite:GetLineRenderFirstPosition()
   if self.m_Core == nil then return nil end
   return self.m_Core:GetLineRenderFirstPosition()
end

function SGSprite:GetLineRenderLength()
   if self.m_Core == nil then return 0 end
   return self.m_Core:GetLineRenderLength()
end

function SGSprite:GetLineRenderPositions()
   if self.m_Core == nil then return nil end
   return self.m_Core:GetLineRenderPositions()
end

function SGSprite:GetLineRenderPositionCount()
   if self.m_Core == nil then return 0 end
   return self.m_Core:GetLineRenderPositionCount()
end

function SGSprite:IsLineRenderReadyed()
   if self.m_Core == nil then return false end
   return self.m_Core:IsLineRenderReadyed()
end
----------------------------------------------------------


-----------------------------------------------------------------------网络同步--------------------------------------------------
function SGSprite:OnSyncStateNavigate(endPos, angle, navRate, navType)
    self:ChangeToNavigateWithDestination(endPos)
end

function SGSprite:OnSyncStateNavigationEnd()
    self:StopNavigate()
end

return SGSprite
