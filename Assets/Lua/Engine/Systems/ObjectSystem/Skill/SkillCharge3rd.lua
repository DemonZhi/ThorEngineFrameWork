---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/3/9 16:34
---
---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/12/1 10:32
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local SkillCharge = require("Engine/Systems/ObjectSystem/Skill/SkillCharge")
local SyncConsts = ComponentDefine.SyncConsts
local MoveSyncType = ComponentDefine.MoveSyncType
local AnimationEventDefines = SGEngine.Core.AnimationEventDefines
local SkillCharge3rd = class("SkillCharge3rd", SkillBase)
local SkillChargeStageEnum = SkillCharge.SkillChargeStageEnum
local StateDefine = SGEngine.Core.StateDefine

function SkillCharge3rd:Ctor()
    SkillCharge3rd.__super.Ctor(self)
end

function SkillCharge3rd:Init(object, skillConfig, targetObjectId, targetPosition)
    self.m_Owner = object
    self.m_Config = skillConfig
    if not skillConfig then
        Logger.LogError("[SkillBase]Init:Empty Skill Config")
        return
    end
    self.m_SkillId = skillConfig.ID
    self.m_IsMoving = false
    self.m_FrameCount = 0
    self.m_StateIndex = 1
    self.m_StartTime = Time.time
    self.m_IsHandleJoyStickEvent = true
    local params = skillConfig.SkillModuleParams
    self.m_ChargeTimeList = params.m_TimeList
    self.m_ChargeSkillList = params.m_SkillIdList
    self.m_CanMove = self.m_Config.MovingSpeed > 0
    local aniName = skillConfig.AnimName
    self.m_PreAnimationName = aniName .. SkillCharge.k_PreAnimationSuffix
    self.m_MoveAnimationName = aniName .. SkillCharge.k_MoveAnimationSuffix
    self.m_IdleAnimationName = aniName .. SkillCharge.k_IdleAnimationSuffix
    self.m_Owner.m_Core:RawUseSkill(skillConfig.ID, skillConfig.SkillModule, targetObjectId, self.m_PreAnimationName)
    self.m_Stage = SkillChargeStageEnum.ChargePre
    self:SetCoreInitParam()
end

function SkillCharge3rd:SetCoreInitParam()
    local owner = self.m_Owner
    if owner == nil then
        return
    end
    owner:SetCurrentMoveSpeed(self.m_Config.MovingSpeed)
    owner:SetCurrentRotateSpeed(self.m_Config.RotateSpeed)
end

function SkillCharge3rd:Destroy()
    self.m_PredictStep = 0
    self.m_CurrentSyncInfo = nil
    SkillCharge3rd.__super.Destroy(self)
end

function SkillCharge3rd:OnSkillMoveStop()
    if self:CheckPredict() then
        self:PredictMove()
    elseif self.m_CurrentSyncInfo.m_SyncType == MoveSyncType.k_SkillMoveStop then
        self:Stop()
    end
end

function SkillCharge3rd:CheckPredict()
    if self.m_PredictStep > SyncConsts.k_Max3rdPredictStep then
        return false
    end

    if self.m_CurrentSyncInfo == nil then
        return false
    end

    local syncType = self.m_CurrentSyncInfo.m_SyncType
    if syncType == MoveSyncType.k_SkillMove then
        return true
    end

    return false
end

function SkillCharge3rd:PredictMove()
    self.m_PredictStep = self.m_PredictStep + 1
    local syncInfo = self.m_CurrentSyncInfo
    local angle = syncInfo.m_Angle
    local owner = self.m_Owner
    local moveSpeed = owner:GetCurrentMoveSpeed()
    local predictPos = owner:PredictPosOnGround(angle, moveSpeed, 1)
    self:Move(predictPos, angle)
end

function SkillCharge3rd:UpdateSyncInfo(syncInfo)
    local owner = self.m_Owner
    self.m_PredictStep = 0
    self.m_CurrentSyncInfo = syncInfo
    local angle = syncInfo.m_Angle
    local syncType = syncInfo.m_SyncType
    local targetPosition = syncInfo.m_TargetPosition
    owner:SetAngle(angle)
    if not self.m_CanMove then
        local position = syncInfo.m_TargetPosition
        self.m_Owner:SetPositionXYZ(position.x, position.y, position.z)
        self:Stop()
        return
    end
    --Logger.LogInfo("UpdateSyncInfoTo:{%f},{%f},{%f},%d, type:%d", targetPosition.x, targetPosition.y, targetPosition.z, Time.frameCount, syncType)
    if syncType == MoveSyncType.k_SkillMove then
        self:Move(targetPosition, angle)
    elseif syncType == MoveSyncType.k_SkillMoveStop then
        local position = targetPosition:Clone()
        local moveSpeed = owner:GetCurrentMoveSpeed()
        position:Sub(self.m_Owner:GetPosition())
        ---fix y
        if position:SqrMagnitude() > moveSpeed * Time.deltaTime * moveSpeed * Time.deltaTime then
            self:Move(targetPosition, angle)
        else
            owner:SetPosition(targetPosition)
            self:Stop()
        end
    end
end

function SkillCharge3rd:Move(predictPos, angle)
    self.m_IsMoving = true
    self.m_Owner.m_Core:OnSyncStateMove(StateDefine.k_StateSkill, predictPos.x, predictPos.y, predictPos.z, angle)
end

function SkillCharge3rd:Stop()
    self.m_IsMoving = false
    self.m_Owner.m_Core:OnSyncStateStopMove(StateDefine.k_StateSkill)
end

function SkillCharge3rd:OnSkillEvent(eventName)
    SkillCharge3rd.__super.OnSkillEvent(self, eventName)
    if eventName == AnimationEventDefines.k_EventEnd then
        self.m_Stage = SkillChargeStageEnum.Charging
        self:CheckAnimation()
    end
end

function SkillCharge3rd:Update(deltaTime)
    SkillCharge3rd.__super.Update(self, deltaTime)
    if self.m_Stage == SkillChargeStageEnum.Charging then
        self:CheckAnimation()
    end
end

function SkillCharge3rd:CheckAnimation()
    if self.m_CanMove and self.m_IsMoving then
        if self.m_Owner:IsPlayingAnimation(self.m_MoveAnimationName) == false then
            self.m_Owner:PlayAnimation(self.m_MoveAnimationName)
        end
    else
        if self.m_Owner:IsPlayingAnimation(self.m_IdleAnimationName) == false then
            self.m_Owner:PlayAnimation(self.m_IdleAnimationName)
        end
    end
end

return SkillCharge3rd