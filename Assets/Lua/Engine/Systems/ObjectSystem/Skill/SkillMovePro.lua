---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/12/1 10:31
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local BattleMessage = require("MainGame/Message/BattleMessage")
local SkillMovePro = class("SkillMovePro", SkillBase)

local AnimationEventDefines = SGEngine.Core.AnimationEventDefines
local StateDefine = SGEngine.Core.StateDefine
local SyncConsts = ComponentDefine.SyncConsts
local MoveSyncType = ComponentDefine.MoveSyncType
local k_AnimationSuffix = "_moving"

function SkillMovePro:Ctor()
    SkillMovePro.__super.Ctor(self)
end

function SkillMovePro:Init(object, skillConfig, targetObjectId, targetPosition)
    self.m_IsMoving = false
    self.m_MoveAnimationName = skillConfig.AnimName..k_AnimationSuffix
    SkillMovePro.__super.Init(self, object, skillConfig, targetObjectId, targetPosition)
    self.m_FrameCount = 0
end

function SkillMovePro:GetParams()
    self.m_HasMoveAnimation = self.m_Owner:ContainAnimation(self.m_MoveAnimationName)
    return self.m_HasMoveAnimation
end

function SkillMovePro:SetCoreInitParam()
    local owner = self.m_Owner
    if owner == nil then
        return
    end

    owner:SetCurrentMoveSpeed(self.m_Config.MovingSpeed)
    owner:SetCurrentRotateSpeed(self.m_Config.RotateSpeed)
end

function SkillMovePro:Destroy()
    if self.m_SkillAngle then
        self.m_Owner:SetAngle(self.m_SkillAngle)
    end
    self.m_SkillAngle = nil
    SkillMovePro.__super.Destroy(self)
end

function SkillMovePro:Update(deltaTime)
    SkillMovePro.__super.Update(self, deltaTime)
    self.m_FrameCount = self.m_FrameCount + 1
    if self.m_IsMoving == true then
        self:CheckSync()
    end

    self:UpdateAngle()
end

function SkillMovePro:UpdateAngle()
    if self.m_Owner:IsSkillEventHandled(AnimationEventDefines.k_EventEnd) then
        return
    end
    local skillTargetComponent = self.m_Owner.m_SkillTargetComponent
    if self.m_IsTurningByUI == false then
        self.m_TargetObjectId = 0
        if skillTargetComponent then
            self.m_TargetObjectId = skillTargetComponent:GetTargetId()
        end
    end

    if self.m_IsTurningByUI == true and self.m_Owner:IsSkillEventHandled(AnimationEventDefines.k_EventRearSwing) == true then
        self.m_TargetObjectId = 0
        if self.m_SkillAngle then
            self.m_Owner:SetAngle(self.m_SkillAngle)
        end
        self.m_IsTurningByUI = false
    end
    if self.m_TargetObjectId ~= 0 then
        self.m_Owner:Turn2TargetWithID(self.m_TargetObjectId, self.m_Config.FaceTargetSpeed)
    end
end

function SkillMovePro:OnSkillButtonMove(angle)
    self.m_IsTurningByUI = true
    self.m_SkillAngle = angle
end

function SkillMovePro:OnSkillButtonDown(angle)
    self.m_IsTurningByUI = true
    self.m_SkillAngle = angle
    self:UpdateAngle()
end

function SkillMovePro:OnSkillButtonUp()
    self.m_SkillAngle = nil
end

--region 同步
function SkillMovePro:SyncMove(moveAngle)
    local owner = self.m_Owner
    if owner == nil then
        return
    end

    if not moveAngle then
        moveAngle = self.m_Owner:GetStateTargetAngle(StateDefine.k_StateSkill)
    end

    local pos = owner:GetPosition()
    local predictStepCount = SyncConsts.k_SyncPosPredictCount
    if predictStepCount > 0 then
        pos = owner:PredictPosOnGroundByController(moveAngle, owner:GetCurrentMoveSpeed(), predictStepCount)
    end
    BattleMessage.SendSkillMove(pos, self.m_Owner:GetAngle(), MoveSyncType.k_SkillMove)
    self.m_LastSyncAngle = moveAngle
end

function SkillMovePro:SyncStop()
    local owner = self.m_Owner
    if owner == nil then
        return
    end

    local posX, posY, posZ = owner:GetPositionXYZ()
    local angle = owner:GetAngle()
    BattleMessage.SendSkillMoveXYZ(posX, posY, posZ, angle, MoveSyncType.k_SkillMoveStop)
end

function SkillMovePro:CheckSync()
    local moveAngle = self.m_Owner:GetStateTargetAngle(StateDefine.k_StateSkill)
    if self:NeedSync(moveAngle) then
        self:SyncMove(moveAngle)
    end
end

function SkillMovePro:NeedSync(moveAngle)
    if self.m_FrameCount % SyncConsts.k_SyncPosFrameCount == 0 then
        return true
    end
    if self.m_LastSyncAngle == nil or Mathf.DeltaAngle(self.m_LastSyncAngle, moveAngle) >= SyncConsts.k_SyncPosDifAngle then
        return true
    end
    return false
end
--endregion

function SkillMovePro:OnSkillMove()
    if self.m_HasMoveAnimation == false and self:IsBreakable() then
        self.m_Owner:ChangeToMove()
    end
    if not self.m_IsMoving then
        self.m_IsMoving = true
        self:SyncMove()
    end
end

function SkillMovePro:OnSkillMoveStop()
    if self.m_IsMoving == true then
        self.m_IsMoving = false
        self:SyncStop()
    end
end

return SkillMovePro