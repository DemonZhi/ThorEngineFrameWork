---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2020/12/1 10:31
---
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local SkillP2P3rd = class("SkillP2P3rd", SkillBase)
local StateDefine = SGEngine.Core.StateDefine
local SyncConsts = ComponentDefine.SyncConsts
local MoveSyncType = ComponentDefine.MoveSyncType

function SkillP2P3rd:Ctor()
    SkillP2P3rd.__super.Ctor(self)
end

function SkillP2P3rd:Init(object, skillConfig, targetObjectId, targetPosition)
    SkillP2P3rd.__super.Init(self, object, skillConfig, targetObjectId, targetPosition)
end

function SkillP2P3rd:SetCoreInitParam()
    local owner = self.m_Owner
    if owner == nil then
        return
    end
    owner:SetCurrentMoveSpeed(self.m_Config.MovingSpeed)
    owner:SetCurrentRotateSpeed(self.m_Config.RotateSpeed)
end

function SkillP2P3rd:Destroy()
    self.m_Owner:UnFreezeAnimator()
    SkillP2P3rd.__super.Destroy(self)
end

function SkillP2P3rd:Update(deltaTime)
    SkillP2P3rd.__super.Update(self, deltaTime)
end

--region 同步
function SkillP2P3rd:CheckPredict()
    if self.m_PredictStep > SyncConsts.k_Max3rdPredictStep then
        return false
    end

    if self.m_CurrentSyncInfo == nil then
        return false
    end

    local syncType = self.m_CurrentSyncInfo.m_SyncType
    if syncType == MoveSyncType.k_SkillMove then
        return true
    end

    return false
end

function SkillP2P3rd:PredictMove()
    self.m_PredictStep = self.m_PredictStep + 1
    local owner = self.m_Owner
    local syncInfo = self.m_CurrentSyncInfo
    local angle = syncInfo.m_Angle
    local moveSpeed = owner:GetCurrentMoveSpeed()
    local predictPos = owner:PredictPosOnGround(angle, moveSpeed, 1)
    owner.m_Core:OnSyncStateMove(StateDefine.k_StateSkill, predictPos.x, predictPos.y, predictPos.z, angle)
end

function SkillP2P3rd:UpdateSyncInfo(syncInfo)
    local owner = self.m_Owner
    self.m_PredictStep = 0
    self.m_CurrentSyncInfo = syncInfo
    local angle = syncInfo.m_Angle
    local syncType = syncInfo.m_SyncType
    local targetPosition = syncInfo.m_TargetPosition
    local x = targetPosition.x
    local y = targetPosition.y
    local z = targetPosition.z
    --Logger.LogInfo("UpdateSyncInfoTo:{%f},{%f},{%f},%d, type:%d", targetPosition.x, targetPosition.y, targetPosition.z, Time.frameCount, syncType)
    if syncType == MoveSyncType.k_SkillMove then
        self.m_IsArrived = false
        owner.m_Core:OnSyncStateMove(StateDefine.k_StateSkill, x, y, z, angle)
    elseif syncType == MoveSyncType.k_SkillMoveStop then
        local position = targetPosition:Clone()
        local moveSpeed = owner:GetCurrentMoveSpeed()
        position:Sub(owner:GetPosition())
        if position:SqrMagnitude() > moveSpeed * Time.deltaTime * moveSpeed * Time.deltaTime then
            self.m_IsArrived = false
            owner.m_Core:OnSyncStateMove(StateDefine.k_StateSkill, x, y, z, angle)
        else
            owner:SetPosition(targetPosition)
            owner:SetAngle(angle)
            owner:UnFreezeAnimator()
            owner.m_Core:OnSyncStateStopMove(StateDefine.k_StateSkill)
        end
    end
end

--endregion

function SkillP2P3rd:OnSkillMoveStop()
    local owner = self.m_Owner
    if self:CheckPredict() then
        self:PredictMove()
    elseif self.m_CurrentSyncInfo.m_SyncType == MoveSyncType.k_SkillMoveStop then
        owner:UnFreezeAnimator()
        owner.m_Core:OnSyncStateStopMove(StateDefine.k_StateSkill)
    end
end

function SkillP2P3rd:OnSkillFrontSwing()
    if self:GetTarget() == nil then
        return
    end
    local syncInfo = self.m_CurrentSyncInfo
    if syncInfo == nil or syncInfo.m_SyncType ~= MoveSyncType.k_SkillMoveStop or not self.m_IsArrived then
        self.m_Owner:FreezeAnimator()
    end
end

function SkillP2P3rd:GetTarget()
    return ObjectManager.GetObject(self.m_TargetObjectId)
end

return SkillP2P3rd