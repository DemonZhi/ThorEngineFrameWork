---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2022/6/20 16:41
---
local StateConsts = require("Engine/Systems/ObjectSystem/State/StateConsts")
---@class StateHitFloat:StateBase
local StateHitFloat = class("StateHitFloat", StateBase)
local StateDefine = SGEngine.Core.StateDefine
local AnimationEventDefines = SGEngine.Core.AnimationEventDefines
local HitTypeEnum = StateConsts.HitTypeEnum
function StateHitFloat.Ctor(owner, stateComponent)
    StateHitFloat.__super.Ctor(owner, stateComponent)
    stateComponent.m_StateHitFloatParam = {}
end

function StateHitFloat.Init(owner, stateComponent)
    StateHitFloat.__super.Init(owner, stateComponent)
    local stateHitFloatParam = stateComponent.m_StateHitFloatParam
    local serverDuration = stateHitFloatParam.m_ServerDuration
    local animName = StateConsts.k_HitFloatAnimationName
    local startEvent = AnimationEventDefines.k_EventStart
    local endEvent = AnimationEventDefines.k_EventEnd
    stateHitFloatParam.m_StartTime = Time.time
    stateHitFloatParam.m_NeedCacheDead = true
    if serverDuration == nil then
        serverDuration = owner:GetTimeBetweenAnimationEvent(animName, startEvent, endEvent)
    end

    stateHitFloatParam.m_Duration = serverDuration
    if serverDuration == 0 then
        owner:DelState(StateDefine.k_StateHitFloat)
        return
    end
    local destination = stateHitFloatParam.m_Destination
    StateHitFloat.SetParamToCore(owner, destination, stateHitFloatParam.m_Speed)

    if not animName then
        --Logger.Error("Try to play empty anim")
        return
    end
    --stateHitFloatParam.m_IsBreakable = false
    owner:SetAngle(stateHitFloatParam.m_Angle)
    StateHitFloat.PlayAnimation(owner, animName, 0.1,function(eventName)
        StateHitFloat.OnAnimationEvent(owner, eventName)
    end)
end

function StateHitFloat.OnAnimationEvent(owner, eventName)
    if eventName == AnimationEventDefines.k_EventRearSwing then
        StateHitFloat.CheckIfDead(owner)
    end
end

function StateHitFloat.CheckIfDead(owner)
    local stateHitFloatParam = owner.m_StateComponent.m_StateHitFloatParam
    stateHitFloatParam.m_NeedCacheDead = false
    local deadParam = stateHitFloatParam.m_DeadParam
    if deadParam ~= nil then
        owner:ChangeToDead(deadParam.m_PosX, deadParam.m_PosY, deadParam.m_PosZ, deadParam.m_Angle, true)
        stateHitFloatParam.m_DeadParam = nil
    end
end

function StateHitFloat.Update(deltaTime, owner, stateComponent)
    local stateHitFloatParam = stateComponent.m_StateHitFloatParam
    if Time.time - stateHitFloatParam.m_StartTime > stateHitFloatParam.m_Duration then
        owner:DelState(StateDefine.k_StateHitFloat)
    end
end

function StateHitFloat.Destroy(owner, stateComponent)
    if owner:IsState(StateDefine.k_StateDaze) then
        local stateDaze = owner:GetState(StateDefine.k_StateDaze)
        stateDaze.Init(owner, stateComponent)
    end
    StateHitFloat.CheckIfDead(owner)
    stateComponent.m_StateHitFloatParam.m_NeedCacheDead = false
    StateHitFloat.__super.Destroy(owner, stateComponent)
end

function StateHitFloat.SetParamToCore(owner, destination, speed)
    owner.m_Core:OnSyncState(StateDefine.k_StateHitFloat, destination.x, destination.y, destination.z, speed)
end

return StateHitFloat