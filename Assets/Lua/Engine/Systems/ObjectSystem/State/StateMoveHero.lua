---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Administrator.
--- DateTime: 2021/1/26 20:47
---
local StateDefine = SGEngine.Core.StateDefine
local StateMoveHero = class("StateMoveHero", StateMove)
local StateConsts = require("Engine/Systems/ObjectSystem/State/StateConsts")
local ComponentDefine = require("Engine/Systems/ObjectSystem/Components/ComponentDefine")
local MoveType = ComponentDefine.MoveType
local BattleMessage = require("MainGame/Message/BattleMessage")
local StateDefine = SGEngine.Core.StateDefine
local AnimationEventDefines = SGEngine.Core.AnimationEventDefines
local SyncConsts = ComponentDefine.SyncConsts
local MoveSyncType = ComponentDefine.MoveSyncType

function StateMoveHero.Ctor(owner, stateComponent)
    StateMoveHero.__super.Ctor(owner, stateComponent)
    if stateComponent.m_StateMoveParam == nil then
        stateComponent.m_StateMoveParam = {}
    end
end

function StateMoveHero.Init(owner, stateComponent)
    StateMoveHero.__super.Init(owner, stateComponent)
    local stateParam = stateComponent.m_StateMoveParam
    stateParam.m_CurrentMoveType = MoveType.None
    stateParam.m_FrameCount = 0
    local isSprint = stateParam.m_IsSprint
    --Logger.LogInfo("IsSprint:"..tostring(isSprint))
    if owner:IsState(StateDefine.k_StateRide) then
        StateMoveHero.SetParamToCore(owner, true, true)
        StateMoveHero.RideRun(owner)
    elseif isSprint then
        StateMoveHero.SetParamToCore(owner, true)
        stateParam.m_IsSprint = false
        StateMoveHero.Sprint(owner)
    else
        StateMoveHero.SetParamToCore(owner, true)
        StateMoveHero.Run(owner)
    end
    owner:SetCurrentMoveSpeed(StateMoveHero.GetMoveSpeed(owner))
    owner:SetCurrentRotateSpeed(StateMoveHero.GetRotateSpeed(owner))
end

function StateMoveHero.Run(owner)
    owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.Run
    StateMoveHero.PlayAnimation(owner, StateMoveHero.GetRunAnimationName(owner))
    StateMoveHero.RunBegin(owner)
end

function StateMoveHero.Sprint(owner)
    owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.Sprint
    StateMoveHero.PlayAnimation(owner, StateConsts.k_SprintAnimationName)
    StateMoveHero.SprintBegin(owner)
end

function StateMoveHero.RideRun(owner)
    local stateRideData = owner.m_StateComponent.m_StateRideParam
    local config = stateRideData.m_MountConfig
    local mount = stateRideData.m_Mount
    owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.RideRun
    StateMoveHero.PlayAnimation(owner, config.RunAnimation, 0)
    if mount:IsModelLoadFinish() == true then
        mount:PlayAnimation(StateConsts.k_RunAnimationName, 0, 0.1)
    end
    StateMoveHero.RideRunBegin(owner)
end

function StateMoveHero.Destroy(owner, stateComponent)
    local stateParam = stateComponent.m_StateMoveParam
    local moveType = stateParam.m_CurrentMoveType
    if moveType == MoveType.Run then
        StateMoveHero.RunStop(owner)
    elseif moveType == MoveType.Sprint then
        StateMoveHero.SprintStop(owner)
    elseif moveType == MoveType.SprintStop or moveType == MoveType.SprintStopRearSwing then
        StateMoveHero.SyncPosition(owner, false)
    elseif moveType == MoveType.SprintTurn then
        ---这里使用转后的朝向，而不是当前朝向
        local targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
        local pos = owner:GetPosition()
        BattleMessage.SendStateMove(pos, targetAngle, MoveSyncType.k_MoveStop)
    elseif moveType == MoveType.RideRun then
        StateMoveHero.RideMoveStop(owner)
    elseif moveType == MoveType.RideMoveStop then
        StateMoveHero.SyncPosition(owner, false)
    end
    stateParam.m_CurrentMoveType = MoveType.None
    StateMoveHero.SetSprintBtnActive(false)
    StateMoveHero.__super.Destroy(owner, stateComponent)
end

function StateMoveHero.Update(deltaTime, owner, stateComponent)
    local stateParam = stateComponent.m_StateMoveParam
    stateParam.m_FrameCount = stateParam.m_FrameCount + 1

    local moveType = stateParam.m_CurrentMoveType
    if moveType == MoveType.Run or moveType == MoveType.RideRun then
        StateMoveHero.CheckSync(owner)
    elseif moveType == MoveType.Sprint then
        local Mathf = UnityEngine.Mathf
        local targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
        local currentAngle = owner:GetAngle()
        local angleDif = Mathf.Abs(Mathf.DeltaAngle(targetAngle, currentAngle))
        local config = owner.m_CharacterConfig
        if angleDif > config.SprintTurnAngle then
            StateMoveHero.SprintTurn(owner)
        else
            StateMoveHero.CheckSync(owner)
        end
    end
end

function StateMoveHero.OnBeginMove(owner, stateComponent)
    local moveType = stateComponent.m_StateMoveParam.m_CurrentMoveType
    if moveType == MoveType.SprintStopRearSwing or moveType == MoveType.RunStop then
        owner:ChangeToMove()
    end
end

function StateMoveHero.OnStopMove(owner, stateComponent)
    local stateMoveParam = stateComponent.m_StateMoveParam
    local currentMoveType = stateMoveParam.m_CurrentMoveType
    stateMoveParam.m_IsSprint = false
    --owner:FixPositionY()
    --Logger.LogInfo("[StateMoveHero](OnStopMove): %s", tostring(currentMoveType))
    if currentMoveType == MoveType.Run then
        if owner:ContainAnimation(StateConsts.k_RunStopAnimationName) then
            stateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.RunStop
            StateMoveHero.PlayAnimation(owner, StateConsts.k_RunStopAnimationName, 0.1, function(eventName)
                StateMoveHero.OnRunStopEvent(owner, eventName)
            end)
        else
            owner.m_Core:DelState(StateDefine.k_StateMove)
            stateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.None
        end
        StateMoveHero.SetParamToCore(owner, false)
    elseif currentMoveType == MoveType.Sprint then
        stateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.SprintStop

        if owner:IsOpenSprintCamera() > 0 then
           owner.m_Core:ActivateMotorWithName(StateConsts.k_SprintToNormalMotorName)
        end

        StateMoveHero.SprintStop(owner)
        StateMoveHero.PlayAnimation(owner, StateConsts.k_SprintStopAnimationName, 0.1, function(eventName)
            StateMoveHero.OnSprintStopEvent(owner, eventName)
        end)
        StateMoveHero.SetParamToCore(owner, false)
    elseif currentMoveType == MoveType.RideRun then
        stateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.RideRunStop
        StateMoveHero.RideMoveStop(owner)
        local stateRideData = stateComponent.m_StateRideParam
        local config = stateRideData.m_MountConfig
        local mount = stateRideData.m_Mount
        StateMoveHero.PlayAnimation(owner, config.RunStopAnimation, 0.1, function(eventName)
            StateMoveHero.OnRideMoveStopEvent(owner, eventName)
        end)
        if mount:IsModelLoadFinish() == true then
            mount:PlayAnimation(StateConsts.k_RunStopAnimationName, 0, 0.1)
        end
        StateMoveHero.SetParamToCore(owner, false)
    else
        owner.m_Core:DelState(StateDefine.k_StateMove)
        stateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.None
    end
end

function StateMoveHero.RunBegin(owner)
    StateMoveHero.SyncMove(owner)
    StateMoveHero.SetSprintBtnActive(true)
end

function StateMoveHero.RunStop(owner)
    StateMoveHero.SyncStop(owner, MoveSyncType.k_MoveStop)
    StateMoveHero.SetSprintBtnActive(false)
end

function StateMoveHero.OnRunStopEvent(owner, eventName)
    if eventName == AnimationEventDefines.k_EventEnd then
        owner.m_Core:DelState(StateDefine.k_StateMove)
    end
end

function StateMoveHero.SprintBegin(owner)
    local stateComponent = owner.m_StateComponent
    local stateParam = stateComponent.m_StateMoveParam
    StateMoveHero.SyncMove(owner)
    StateMoveHero.SetSprintBtnActive(false)
    ActionController.SetSprintAttackBtnActive(true)
    StateMoveHero.StopSprintEffects(owner)
    stateParam.m_SprintEffectIndexes = {}
    --table.insert(stateParam.m_SprintEffectIndexes, owner.m_EffectComponent:PlayNormalEffect(2002))
    --table.insert(stateParam.m_SprintEffectIndexes, owner.m_EffectComponent:PlayNormalEffect(2003))
    --table.insert(stateParam.m_SprintEffectIndexes, owner.m_EffectComponent:PlayNormalEffect(2004))
    --table.insert(stateParam.m_SprintEffectIndexes, owner.m_EffectComponent:PlayNormalEffect(2001))
    --if MotionBlur.Instance ~= nil then
    --    MotionBlur.Instance:SetActive(true)
    --end
    stateParam.m_SprintAfterTurn = true
    if owner:IsOpenSprintCamera() > 0 then --slg场景暂时屏蔽
       owner.m_Core:ActivateMotorWithName(StateConsts.k_NormalToSprintMotorName)
    end
end

function StateMoveHero.SprintStop(owner)
    owner.m_StateComponent.m_StateMoveParam.m_IsSprint = false
    StateMoveHero.StopSprintEffects(owner)
    StateMoveHero.SyncStop(owner, MoveSyncType.k_SprintStop)
    ActionController.SetSprintAttackBtnActive(false)
    --if MotionBlur.Instance ~= nil then
    --    MotionBlur.Instance:SetActive(false)
    --end
end

function StateMoveHero.SprintTurn(owner)
    owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.SprintTurn
    local targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
    StateMoveHero.StopSprintEffects(owner)
    StateMoveHero.SetParamToCore(owner, false)
    BattleMessage.SendStateMove(owner:GetPosition(), targetAngle, MoveSyncType.k_SprintTurn)
    StateMoveHero.PlayAnimation(owner, StateConsts.k_SprintTurnAnimationName, 0.1, function(eventName)
        StateMoveHero.OnSprintTurnEvent(owner, eventName)
    end)
end

function StateMoveHero.OnSprintTurnEvent(owner, eventName)
    if eventName == AnimationEventDefines.k_EventEnd then
        StateMoveHero.SetParamToCore(owner, true)
        local targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
        owner:SetAngle(targetAngle)
        if owner:IsState(StateDefine.k_StateMove) == false then
            return
        end
        if owner.m_StateComponent.m_StateMoveParam.m_SprintAfterTurn == true then
            StateMoveHero.Sprint(owner)
        else
            StateMoveHero.Run(owner)
        end
    end
end

function StateMoveHero.OnSprintStopEvent(owner, eventName)
    if eventName == AnimationEventDefines.k_EventRearSwing then
        owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.SprintStopRearSwing
    elseif eventName == AnimationEventDefines.k_EventEnd then
        owner.m_Core:DelState(StateDefine.k_StateMove)
    end
end

function StateMoveHero.RideRunBegin(owner)
    StateMoveHero.SyncMove(owner)
end

function StateMoveHero.RideMoveStop(owner)
    StateMoveHero.SyncStop(owner, MoveSyncType.k_RideMoveStop)
end

function StateMoveHero.OnRideMoveStopEvent(owner, eventName)
    if eventName == AnimationEventDefines.k_EventRearSwing then
        owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType = MoveType.RideRunStopRearSwing
        StateMoveHero.SyncPosition(owner, false)
    elseif eventName == AnimationEventDefines.k_EventEnd then
        owner.m_Core:DelState(StateDefine.k_StateMove)
    end
end

function StateMoveHero.StopSprintEffects(owner)
    local stateComponent = owner.m_StateComponent
    local stateParam = stateComponent.m_StateMoveParam
    if stateParam.m_SprintEffectIndexes then
        for i, v in ipairs(stateParam.m_SprintEffectIndexes) do
            owner.m_EffectComponent:StopNormalEffect(v)
        end
        stateParam.m_SprintEffectIndexes = nil
    end
end

function StateMoveHero.SetSprintBtnActive(active)
    local skillView = UIManager.GetUI("SkillView")
    if skillView then
        skillView:SetSprintBtnActive(active)
    end
end

function StateMoveHero.GetMoveSpeed(owner)
    local stateComponent = owner.m_StateComponent
    local currentMoveType = stateComponent.m_StateMoveParam.m_CurrentMoveType
    local attributeDefine = ComponentDefine.AttributeDefine
    if currentMoveType == MoveType.Run or currentMoveType == MoveType.SprintStop then
        return owner.m_AttrComponent:GetAttribute(attributeDefine.k_MoveSpeed)
    elseif currentMoveType == MoveType.Sprint then
        return owner.m_AttrComponent:GetAttribute(attributeDefine.k_SprintSpeed)
    elseif currentMoveType == MoveType.RideRun then
        local config = stateComponent.m_StateRideParam.m_MountConfig
        return config.MoveSpeed
    end
    return 0
end

function StateMoveHero.GetRotateSpeed(owner)
    local stateComponent = owner.m_StateComponent
    local currentMoveType = stateComponent.m_StateMoveParam.m_CurrentMoveType
    local attributeDefine = ComponentDefine.AttributeDefine
    if currentMoveType == MoveType.Run then
        return owner.m_AttrComponent:GetAttribute(attributeDefine.k_RotateSpeed)
    elseif currentMoveType == MoveType.Sprint then
        return owner.m_AttrComponent:GetAttribute(attributeDefine.k_SprintRotateSpeed)
    elseif currentMoveType == MoveType.RideRun then
        local config = stateComponent.m_StateRideParam.m_MountConfig
        return config.RotateSpeed
    end
    return 0
end

function StateMoveHero.GetCurrentMoveType(owner)
    return owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType
end

function StateMoveHero.SetParamToCore(owner, movable, useCurrentAngleToMove)
    if not useCurrentAngleToMove then
        useCurrentAngleToMove = false
    end
    owner.m_Core:OnSyncState(StateDefine.k_StateMove, movable, useCurrentAngleToMove)
end

--region 同步
function StateMoveHero.CheckSync(owner)
    local targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
    if StateMoveHero.NeedSync(owner, targetAngle) then
        StateMoveHero.SyncMove(owner, targetAngle)
    end
end

function StateMoveHero.NeedSync(owner, targetAngle)
    local stateMoveParam = owner.m_StateComponent.m_StateMoveParam
    local currentMoveType = stateMoveParam.m_CurrentMoveType
    if currentMoveType ~= MoveType.Run and currentMoveType ~= MoveType.Sprint and currentMoveType ~= MoveType.RideRun then
        return false
    end
    if stateMoveParam.m_FrameCount % SyncConsts.k_SyncPosFrameCount == 0 then
        return true
    end
    local currentAngle = owner:GetAngle()
    local difAngle = SyncConsts.k_SyncPosDifAngle
    if currentMoveType == MoveType.RideRun then
        difAngle = SyncConsts.k_SyncPosDifAngleRide
    end
    if math.abs(targetAngle - currentAngle) >= difAngle then
        return true
    end
    return false
end

function StateMoveHero.SyncMove(owner, targetAngle)
    if owner:IsState(StateDefine.k_StateRide) then
        StateMoveHero.SyncMoveRide(owner, targetAngle)
    else
        StateMoveHero.SyncMoveNormal(owner, targetAngle)
    end
end

function StateMoveHero.SyncMoveNormal(owner, targetAngle)
    if not targetAngle then
        targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
    end
    if owner == nil then
        return
    end
    local pos
    local predictStepCount = SyncConsts.k_SyncPosPredictCount
    if predictStepCount > 0 then
        pos = owner:PredictPosOnGroundByController(targetAngle, owner:GetCurrentMoveSpeed(), predictStepCount)
    else
        pos = owner:GetPosition()
    end

    local syncType = MoveSyncType.k_Move
    if owner.m_StateComponent.m_StateMoveParam.m_CurrentMoveType == MoveType.Sprint then
        syncType = MoveSyncType.k_Sprint
    end
    BattleMessage.SendStateMove(pos, targetAngle, syncType)
end

function StateMoveHero.SyncMoveRide(owner, targetAngle)
    if not targetAngle then
        targetAngle = owner:GetStateTargetAngle(StateDefine.k_StateMove)
    end
    if owner == nil then
        return
    end
    local syncAngle = SGEngine.Core.InputManager.Instance.JoystickAngle
    local pos, resultAngle
    local predictStepCount = SyncConsts.k_SyncPosPredictCount
    if predictStepCount > 0 then
        pos, resultAngle = owner:PredictPosOnGroundStepByStepByControllerWithTargetAngle(owner:GetCurrentMoveSpeed(), owner:GetCurrentRotateSpeed(), predictStepCount, targetAngle)
    else
        pos = owner:GetPosition()
    end

    local syncType = MoveSyncType.k_RideMove
    BattleMessage.SendStateMove(pos, resultAngle, syncType, syncAngle)
end

function StateMoveHero.SyncStop(owner, syncType)
    if owner == nil then
        return
    end

    --Logger.LogInfo("Sync Stop:syncType: %s", syncType)
    local pos = owner:GetPosition()
    local angle = owner:GetAngle()
    BattleMessage.SendStateMove(pos, angle, syncType)
end

function StateMoveHero.SyncPosition(owner, needBroadcast)
    if owner == nil then
        return
    end

    local x, y, z = owner:GetPositionXYZ()
    local angle = owner:GetAngle()
    --Logger.LogInfo("SyncPosition: %s,%s,%s", tostring(pos.x), tostring(pos.y), tostring(pos.z))
    BattleMessage.SendSyncPosition(x, y, z, angle, needBroadcast)
end
--endregion
return StateMoveHero